<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise基础]]></title>
    <url>%2F2018%2F10%2F17%2FPromise%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是Promise？所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。优点：可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。缺点：1、无法取消Promise，一旦新建它就会立即执行，无法在中途取消。2、如果不设置回调函数，Promise内部抛出的错误不会反应到外部。3、当处于Pending（进行中）状态值时，无法得知进展到哪一阶段。1234567891011121314151617181920var promise = new Promise( //异步执行，Promise对象创建后会被立即执行 function (resolve,reject) &#123; //耗时很长的异步操作 if(&apos;异步处理成功&apos;) &#123; resolve(); //数据处理成功时调用 &#125; else &#123; reject(); //数据处理失败时调用 &#125; &#125;)//Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。promise.then( function A() &#123; //数据处理成功后执行 &#125;, function B() &#123; //数据处理失败后执行 &#125;) Promise构造函数接受一个函数作为参数，该函数两个参数是resolve和reject，它们是两个函数，由JavaScript引擎提供。•resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去。•reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。•then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为 Reject时调用（第二个是可选的）。如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例。 用promise手写ajax123456789101112131415161718192021222324// ajax函数将返回Promise对象:function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125;var log = document.getElementById(&apos;test-promise-ajax-result&apos;);var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);p.then(function (text) &#123; // 如果AJAX成功，获得响应内容 log.innerText = text;&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码 log.innerText = &apos;ERROR: &apos; + status;&#125;); Promise中的异步模式有哪些？有什么区别？好吧，这个问题可能会把面试者问懵……可以考虑另一种问法，或者直接进入下一个问题，说一说Promise.all()和Promise.race()的区别。因为ES6中的Promise中只有这两个模式all和race，其他的如first、any、last等都是其他Promise库提供的。回到问题本身，Promise.all()和Promise.race()的区别all会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。race会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？all会立即决议，决议结果是fullfilled，值是undefinedrace会永远都不决议，程序卡死…… Promise是如何捕获异常的？与传统的try/catch相比有什么优势？传统的try/catch捕获异常方式是无法捕获异步的异常的，代码如下：12345678try &#123; setTimeout(function()&#123; undefined(); //undefined不是一个方法，会抛出异常 &#125;, 500)&#125; catch(err)&#123; //这里并不能捕获异常 console.log(err);&#125; 而对于Promise对象来说，构造Promise实例时的代码如果出错，则会被认为是一个拒绝的决议，并会向观察回调中传递异常信息。所以即使是一个异步的请求，Promise也是可以捕获异常的。此外，Promise还可以通过catch回调来捕获回调中的异常。Promise是一个不错异步操作解决方案，他解决了传统的通过回调和事件来解决异步操作的诸多问题，如“竞争”，回调信任度低的问题。ES6中也提供了标准的Promise供大家使用。 如何解决异步回调地狱promise、generator、async/await有三个函数，内部实现都是异步的，怎么让这三个函数变成一个同步的，以节省时间promise.allPromise状态一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是面向对象，有什么特点？一切皆为对象：Object，生活中常说的“东西”就是程序里面所指的对象；生活中遇到的东西我们都在下意识的归类；归类意味着抽象模型；类class，对某类众多对象的共同特点抽象出来的模型。类是好多对象的抽象，对象是类的实例化。封装：组件化，便于理解、替换与复用，因此系统会更加灵活。（不同对象的成员变量只属于各自的对象，彼此不受影响。）继承：多态：为了便于改写原有的功能。通过继承实现的不同对象调用相同的方法，表现出不同的行为，称之为多态。真正的多态使用override来实现的。 面向对象/过程，区别“面向过程”是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。 ”面向对象“是以“对象”为中心的编程思想。面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 js怎么实现面向对象封装：即隐藏对象的一些私有的属性和方法，JS中通过设置对象的getter，setter方法来拦截你不想被访问到的属性或方法。继承：super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 静态方法 static123456789101112class People &#123; static print()&#123; console.log(100) &#125;&#125;var p = new People();p.print(); //报错People.print(); //100People.prop=1; //静态属性，People.prop返回1 所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承。而是直接通过类来调用，这就称为“静态方法”。这能这样调用People.print();父级的静态方法可以被子级继承。ES6规定class只有静态方法没有静态属性。枚举要显示指定枚举的底层数据类型很简单，只需在声明枚举的时候加个冒号，后面紧跟要指定的数据类型。 enum sex : byte { //显示指定枚举的底层数据类型 male, female, //此逗号可以省略 }; //此分号可以省略]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP知识小结]]></title>
    <url>%2F2018%2F09%2F26%2FHTTP%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTTPget和post的区别因为GET方法请求的参数都是放在请求的url上的，所以它与POST有以下明显的区别：（1）GET请求可以被添加到书签中，也可保存在浏览器历史记录中，POST不能（2）GET请求可以被浏览器缓存，POST不能（3）GET请求收到URL长度限制，所以数据长度也受限制，lPOST不会。（4）GET请求只能传输ASCII字符，而POST不受此限制，还可以传输二进制数据在语义上两个方法也有区别：（1）GET 代表获取指定服务器上资源，POST 代表向指定的资源提交要被处理的数据（2）GET产生一个TCP数据包；POST产生两个TCP数据包。（3）对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。但是需要多解释两句的是：数据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 http 2.0对于http 1.x有哪些优点？（1）多路复用：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。由于http 1.x的时代中，浏览器向同一域名下发送的http请求数量是受限的，当超出数量限制时，请求会被阻塞，大大降低了用户体验。而HTTP/2 的多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。（2）二进制分帧：HTTP/2在应用层和传输层之间追加了一个二进制分帧层，最终使得多个数据流共用一个连接，更加高效的使用tcp连接。从而使得服务器的连接压力减轻，降低了内存的消耗，增大了网络的吞吐量。（3）首部压缩：HTTP/2引入了HPACK算法对头部进行压缩，大大减小了数据发送的字节数。 说一说你知道的HTTP状态码关于HTTP状态码应该有下面的基本认识：1xx ：接受的请求正在处理2xx ：请求成功3xx ：请求被重定向4xx ：请求错误，表明客户端发送的请求有问题5xx ：服务器错误，表明服务端在处理请求时发生了错误200 ：OK，表明请求成功完成，所有资源成功发送给客户端；204 ：No Content 请求处理成功，但没有资源返回；206 ：Partial Content 客户端进行了范围请求，服务器成功执行请求；301 ：Moved Permanently 资源的URI已更新302:303：资源的URI已更新304 ：Not Modified 客户端有缓存的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户端只想到指定日期后再更新文档）。服务器告诉客户请求未满足条件，原来缓存的文档还可以继续使用。400 ： Bad Request 请求出现语法错误401 ： Unauthorized 访问被拒绝，请求需要通过HPPT认证403 ： Forbidden 访问被服务器拒绝了404 ： Not Found 无法找到指定位置的资源。405 ： Method Not Allowed 请求方法（GET、POST、PUT等）对指定的资源不适用，用来访问本资源的HTTP方法不被允许。500 ： Internal Server Error 服务器执行请求时发生了错误，可能是应用的bug或某些临时的故障。502 ： Bad Gateway 服务器作为网管或者代理时收到了无效的响应。503 ： Service Unavailable 服务不可用，服务器由于维护或者负载过中未能应答。504 ： Gateway Timeout 网关超时，作为代理或网关的服务器不能及时的应答。 HTTP的缺点：1、通信使用明文（HTTP本身不具备加密的功能），内容可能被窃听。窃听只需要收集在互联网上流动的数据包就行了。对于收集来的数据包的解析工作，可以交给那些抓包工具Packet Capture或嗅探器Sniffer工具。2、不验证通信方的身份就可能遭遇伪装。由于不存在确认通信方的处理步骤，任何人都可发起请求。3、无法证明报文的完整性，可能已经遭到篡改。 http和https的基本概念https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层（Secure Socket Layer，安全套接层），https协议的主要作用是：建立一个信息安全通道，来确保数据的传输。SSL还使用了证书的手段，来确认通信方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。HTTP加密、认证机制及完整性保护就是HTTPS（HTTP Secure）。会在登录页面和购物结算页面使用。当使用SSL时，则演变成先和SSL通信，再和TCP通信。简言之，HTTPS就是身披SSL协议这层外壳的HTTP。 http和https的区别？http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。主要的区别如下：Https协议需要ca证书，费用较高。http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 https协议的工作原理1、客户端发送Client Hello报文开始SSL通讯。报文包含客户端支持的SSL的指定版本，加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度）。2、服务器可以进行SSL通讯时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器端加密组件内容是从步骤1接收到客户端加密组件内筛选出来的。3、之后服务器发送Certificate报文。报文中包含公开密钥证书。4、最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。5、SSL第一次握手结束并验证通过后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种称为Pre-master secret的随机密码串。该报文已经用步骤3中的公开密钥进行加密。6.接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。7.客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准。（已采用Pre-master secret密钥加密）8.服务器同样发送Change Cipher Spec报文。9.服务器同样发送Finished报文。10.服务器和客户端的Finished报文交换完毕之后，SSL连接建立完成，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。11.应用层协议通信，即发送HTTP响应。12.最后由客户端断开连接。断开连接时，发送close notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通讯。 https协议的优点1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。4、谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https协议的缺点1、https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。2、加密会消耗更多的CPU及内存资源。3、https缓存不如http高效，会增加数据开销。4、SSL证书也需要钱，功能越强大的证书费用越高。5、SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。 TCP三次握手第一次第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK（acknowledgement）包，此时服务器进入SYN_RECV状态；第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 TCP和UDP的区别（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。（4）TCP只能是1对1的，UDP支持1对1,1对多。（5）TCP的首部较大为20字节，而UDP只有8字节。（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。 WebSocket的实现和应用(1)什么是WebSocket?WebSocket是HTML5中的协议，全双工通信协议，支持持久连续，由客户端发起连接，一旦确认websocket通信连接，任意一方都可以直接向对方发送报文。多了下面2个属性：Upgrade:webSocketConnection:Upgrade告诉服务器发送的是websocketSec-WebSocket-Key: 握手过程中的键值Sec-WebSocket-Protocol: 子协议Sec-WebSocket-Version: 13(2)具体有什么优点？推送功能，减少通信量。 WebSocket与http协议不同的地方：（1）http只能由客户端发起，而webSocket是双向的。（2）webSocket传输的数据包相对于http而言很小，很适合移动端使用。（3）没有同源限制，可以跨域共享资源12.fetch发送2次请求的原因fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。 告诉HTTP客户端需与服务端保持长连接的header是(Connection: Keep-Alive)14．HTTP协议中属于safe method的method(是GET、HEAD)。head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。 TCP与UDP特点与区别TCP UDP 可靠性 可靠 不可靠连接性 面向连接 无连接报文 面向字节流(从进程流出和流入进程的都是字节) 面向报文(保留报文的边界)效率 传输效率低 传输效率高双工性 全双工 一对一，多对多，一对多，多对一流量控制 窗口滑动 无拥塞控制 有(慢开始，拥塞避免，快重传，快回复) 无 TCP与HTTP的关系（1）HTTP协议是基础TCP协议的。客户端向服务端发送HTTP请求，首先要与服务端建立TCP连接，即三次握手，握手之后可以进行数据交互。（2）HTTP是基于请求响应模式且无状态的协议，1.1之前只支持短连接，即请求一次响应之后连接断开，下次请求需要重新进行TCP连接。而1.1之后是支持长连接的，即进行一次TCP连接后，客户端可以发送多个HTTP请求给服务端。HTTPS的加密在哪一层实现应用层与传输层之间IP协议需要知道端口吗不需要，TCP／UDP协议需要知道端口。TCP的可靠传输以及流量控制是如何实现的三次握手，窗口滑动。 请列举减少HTTP请求数和资源文件大小的方法1.合并文件。2.雪碧图。3.图标字体文件(iconfont)。4.base64: data:url5.使用缓存 HTTP头中哪些是和缓存相关的？（1）pragma: no-cache（2）Expires, 它的值是一个格林尼治时间，表示过期时间，pragma的优先级高于Expires, 但是它的时间是相对于服务器的，如果本地时间有问题，那么就没有多大的用处。（3）cache-control（4）缓存校验字段: Last-Modified, ETag。Last-Modified只是定义的时间，但是如果一个资源被修改了, 但是实际内容并没有被修改，那么这样，还是会浪费的，因此有了ETag，比如md5编码。 从输入URL到页面加载发生了什么：.DNS解析.TCP连接.发送HTTP请求.服务器处理请求并返回HTTP报文.浏览器解析渲染页面.连接结束请求方法：GET, POST, PUT, DELETE, OPTIONS, HEADvue中keep-alive作用：keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 ## 进程与线程的区别进程的概念: 进程是一个具有独立功能的程序，它是系统进行资源分配和调度的独立单位。可以说进程是可以独立运行的程序。线程的概念: 线程是进程的一个实体，它是CPU调度和分派的基本单位。线程一般不拥有资源，它只是暂用一些寄存器，计数器，栈。它们的区别:一个线程只属于一个进程，一个进程拥有多个线程。资源分配给进程，同一进程的所有线程共享进程的所有资源。线程作为调度和分派的基本单位，而进程作为分配资源的基本单位。 ISO的七层模型是什么七层模型称为开放式系统互联参考模型应用层网络服务与最终用户的一个接口。协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP表示层数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，JPEG、ASCll、DECOIC、加密格式等会话层建立、管理、终止会话。（在五层模型里面已经合并到了应用层）对应主机进程，指本地主机与远程主机正在进行的会话传输层定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层网络层进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP数据链路层建立逻辑连接、进行硬件地址寻址、差错校验 [2] 等功能。（由底层网络定义协议）将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。物理层建立、维护、断开物理连接。（由底层网络定义协议）。 TCP/IP四层模型：1.链路层（数据链路层/网络接口层）：包括操作系统中的设备驱动程序、计算机中对应的网络接口卡。2.网络层（互联网层）：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传给对方。3.传输层：主要为两台主机上的应用提供端到端的通信。TCP transmission control protocol，传输控制协议和UDP user data protocol。4.应用层：负责处理特定的应用程序细节。FTP，DNS，HTTP。根域名主机是什么全球共有13台根域名服务器。这13台根域名服务器中名字分别为“A”至“M”，其中10台设置在美国，另外各有一台设置于英国、瑞典和日本。根服务器主要用来管理互联网的主目录，所有根服务器均由美国政府授权的互联网域名与号码分配机构ICANN统一管理，负责全球互联网域名根服务器、域名体系和IP地址等的管理。功用：在根域名服务器中虽然没有每个域名的具体信息，但储存了负责每个域（如COM、NET、ORG等）的解析的域名服务器的地址信息。浏览器的缓存分为哪几种。http缓存、websql、indexDB、cookie、localstorage、sessionstorage、application cache、cacheStorage、flash缓存。页面间通信常以页面间调用实现（1）父页面调用子iframe页面：通过iframe的ID获取子页面的dom，然后通过内置属性contentWindow取得子窗口的window对象。（2）子iframe页面调用父页面：通过parent或top对象获取父页面的window对象内元素及方法。（3）主页面内兄弟iframe页面之间相互调用：通过兄弟iframe的ID获取其dom，然后通过内置属性contentWindow取得window对象。 四次挥手由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。（3） 服务器关闭客户端的连接，发送一个FIN给客户端。（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 域名收敛是什么PC 时代为了突破浏览器的域名并发限制。有了域名发散。浏览器有并发限制，是为了防止DDOS攻击。域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。accept是什么，怎么用首部字段告知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浮动与布局]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[浮动与布局负边距与浮动布局所谓的负边距就是margin取负值的情况，如margin:-100px，margin:-100%。当一个元素与另一个元素margin取负值时将拉近距离。常见的功能如下： 向上移动当多个元素同时从标准流中脱离开来时，如果前一个元素的宽度为100%宽度，后面的元素通过负边距可以实现上移。当负的边距超过自身的宽度将上移，只要没有超过自身宽度就不会上移。1234567891011121314151617 #div1 &#123; height: 100px; background: lightblue; width: 100%; float: left; &#125; #div2 &#123; height: 100px; background: lightgreen; width: 30%; float: left; margin-left: -100%; &#125;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;/body&gt; 去除列表右边框开发中常需要在页面中展示一些列表，如商品展示列表等，如果我们要实现如下布局：1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; #div1 &#123; width: 780px; margin: 0 auto; border: 3px solid lightblue; overflow: hidden; margin-top: 10px; &#125; .box &#123; width: 180px; height: 180px; margin: 0 20px 20px 0; background: lightgreen; float: left; &#125;#div2&#123; margin-right: -20px; margin-bottom: -20px; overflow: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;div id=”div2”&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 圣杯布局12345678910111213141516171819202122232425262728293031323334 &lt;style type=&quot;text/css&quot;&gt; .container &#123; padding: 0 300px 0 200px; //左右各剩余了一块区域 &#125; .left, .main, .right &#123; position: relative; min-height: 130px; float: left; &#125; .left &#123; left: -200px; margin-left: -100%; background: green; width: 200px; &#125; .right &#123; right: -300px; margin-left: -300px; background-color: red; width: 300px; &#125; .main &#123; background-color: blue; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 在不增加额外标签的情况下，圣杯布局已经非常完美，圣杯布局使用了相对定位，以后布局是有局限性的，而且宽度控制要改的地方也多。在淘宝UED（User Experience Design）探讨下，增加多一个div就可以不用相对布局了，只用到了浮动和负边距，这就是我们所说的双飞翼布局。 双飞燕布局123456789101112131415161718192021222324252627282930&lt;style type=&quot;text/css&quot;&gt; #center, #left, #right &#123; height: 100%; float: left; &#125; #center &#123; width: 100%; background: lightgreen; &#125; #right &#123; background: lightblue; width: 20%; margin-left: -20%; &#125; #left &#123; background: lightcoral; width: 20%; margin-left: -100%; &#125; #main-inner &#123; padding-left: 20%; &#125;&lt;/style&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;center&quot;&gt; &lt;div id=&quot;main-inner&quot;&gt; center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt; left &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; right&lt;/div&gt; &lt;/div&gt; Flex布局：可以简便、完整、响应式地实现各种页面布局。弹性布局，任何一个容器都可以指定为Flex布局，display: flex。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex主要解决两个问题：元素位置：由6个容器属性和2个项目属性控制6个容器属性 flex-direction （项目的排列方向）row 默认值，排成一行| row-reverse | column | column-reverse项目的排列方向 flex-wrap nowrap（默认）：不换行 | wrap | wrap-reverse; flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content flex-start （默认值）：左对齐| flex-end右对齐 | center 居中| space-between两端对齐 | space-around每个项目两侧的间隔相等; align-items 项目在交叉轴上如何对齐 align-content 定义了多根轴线的对齐方式2个项目属性 Order 项目的排列顺序 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 元素尺寸或自适应能力：由4个项目属性控制flex-grow 能分配到空间比例，属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 收缩比率，默认为1，即如果空间不足，该项目将缩小。 flex-basis 伸缩基准值，属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 Flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。 用flex实现圣杯布局1234567891011121314151617&lt;style&gt; .flex-box&#123; display: flex; height:200px; width:100%; background:red; &#125; .item:nth-child(2)&#123; flex:1; background:red; &#125; &lt;/style&gt;&lt;div class=&quot;flex-box&quot;&gt;&lt;div class=&quot;item&quot; style=&quot;width:200px;background:yellow&quot;&gt;左&lt;/div&gt;&lt;div class=&quot;item&quot;&gt; 中&lt;/div&gt;&lt;div class=&quot;item&quot; style=&quot;width:200px;background:yellow&quot;&gt;右&lt;/div&gt;&lt;/div&gt; 我们left和right设置了固定的宽度，然后将flex-basis设置为0，使得容器的剩余空间仅为容器总宽度减去left和right的宽度，不减去center本身内容的宽度，我们的剩余空间是包括减去自身内容宽度后的宽度；然后设置flex-grow和flex-shrink设置为1，将剩余的宽度全部分配给自己，不管宽度是有剩余还是溢出，也达到了自适应的要求。 CSS3多列布局模块CSS3为了满足这个要求增加了多列布局模块，如果需要实现多列布局模块先看看这几个CSS3属性：column-count: 3; /分3栏/column-gap: 40px; /栏间距/column-rule: 2px solid lightgreen; /栏间分隔线/ 解决由于浮动产生的高度坍塌float 会尽量靠上尽量靠左（右），对父级元素产生影响，高度会塌陷。我们经常会遇到一种情况，给一个元素设置浮动之后 float:left/right;，如果该元素的父元素有背景颜色，那么会发现父元素的背景颜色消失了；如果父元素有一个边框，那么浮动元素无法将边框撑开。元素浮动后，就不在整个文档流的管辖范围，那么它之前存在在父元素内的高度就随着浮动不复存在了，而此时父元素会默认自己里面没有任何内容（前提是未给父元素设置固定高度，如果父元素本身有固定高度，就不会出现这种情况）解决方法：1、给父元素也添加float。这样让父元素与子元素一起脱离文档流浮动起来，保证子元素在父元素内，这样父元素就能自适应子元素的高度，但是此方法有一弊端，一定会影响父元素之后的元素排列，甚至影响布局。2、给父元素一个固定高度，此方法适用于子元素高度已知并且固定的情况。3、添加一个块级元素，并给此元素设置clear:both;清除浮动。在很早之前用的就是这种解决办法，新建一个空的div，为这个div设置clear：both；这样无疑是增加了无意义的标签，一个大型页面中，这种标签太多是不好的。4、给父元素添加 overflow：hidden；5、通过伪类::after清除浮动 垂直居中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667(1)margin:auto法div&#123; width: 400px; height: 400px; position: relative; border: 1px solid #465468; &#125; img&#123; position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125;&lt;div&gt; &lt;img src=&quot;mm.jpg&quot;&gt;&lt;/div&gt;定位为上下左右为0，margin：0可以实现脱离文档流的居中.(2)margin负值法.container&#123; width: 500px; height: 400px; border: 2px solid #379; position: relative;&#125;.inner&#123; width: 480px; height: 380px; background-color: #746; position: absolute; top: 50%; left: 50%; margin-top: -190px; /*height的一半*/ margin-left: -240px; /*width的一半*/ &#125;补充：其实这里也可以将marin-top和margin-left负值替换成， transform：translateX(-50%)和transform：translateY(-50%)(3)table-cell（未脱离文档流的）设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。div&#123; width: 300px; height: 300px; border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;&#125;img&#123; vertical-align: middle;&#125;(4)利用flex将父元素设置为display:flex，并且设置align-items:center;justify-content:center;.container&#123; width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; &#125; .inner&#123; border: 3px solid #458761; padding: 20px; &#125; width与height设置的百分比是相对谁来计算的？padding与margin呢？一、font-size当前的字体大小等于100%二、line-heightline-height的计算值就是当前字体的值乘以该百分比。三、width正常文档流中和设置浮动的情况下，相对于父元素content-box的宽度；绝对定位时，相对于包含块padding-box的宽度。四、heightheight对百分比也是支持的，但是其和width还是有一个明显的区别：当父元素width属性为auto时，子元素宽度仍然可以使用百分比设置。但是对于height，只要子元素还是在正常文档流当中的，如果父元素的height属性为auto，则子元素height设置为百分比会被忽略。规范中指出：如果包含块的高度没有显式指出（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto。而auto*100/100=NaN。所以，若要高度的百分比设置有效，需要如下设置：html,body{ height:100%}上述高度计算，都是对于正常流。五、margin、padding无论是垂直或水平方向，均是相对于父元素的宽度，正常文档流中和设置浮动的情况下，相对于父元素content-box的宽度；绝对定位时，相对于包含块padding-box的宽度。七、定位元素的left/right/bottom/top百分比值 top,bottom设置百分比定位是按包含块padding-box的高度来计算的，同样left,right,设置百分比定位是按包含块padding-box的宽度来计算的。请问你了解vm vh这个单位吗？vw : 1vw 等于视口宽度的1%vh : 1vh 等于视口高度的1%如何居中div,如何居中一个浮动元素?给div设置一个宽度，然后添加margin:0 auto属性设置容器的浮动方式为相对定位 确定容器的宽高 宽500 高 300 的层 设置层的外边距 .Div { Width:500px ; height:300px; Margin: -150px 0 0 -250px; position: absolute; left:50%; top:50%;} display block 象块类型元素一样显示。 none 此元素不会被显示。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示(受到width和height的影响，但不单独占满一行)。 list-item 象块类型元素一样显示，并添加样式列表标记。 positionabsolute 生成绝对定位的元素，相对于具有定位属性（static以外的）第一个父元素进行定位。fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。relative 生成相对定位的元素，相对于其正常位置进行定位。static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。inherit 规定应该从父元素继承 position 属性的值。Sticky 兼容性 CSS3的position的新值: sticky, 它是relative和fixed的组合体，然后可以设置top, left, bottom, right为阀值, 超过阀值以relative表现，小于阀值以fixed表现。 左边定宽右边自适应的两列布局12345678910111213141516171819202122232425262728293031323334353637 1、浮动.left &#123; float: left; width: 100px;&#125;.right &#123; margin-left: 110px;&#125;2、flex.parent &#123; display: flex;&#125;.left &#123; width: 100px; margin-rigth: 100px;&#125;.right &#123; flex: 1;&#125;3、position:absolute.content&#123; position: relative; width: 100%; height: 500px; border: 1px solid #000;&#125;.left&#123; background:#fcc; width: 200px; position: absolute;&#125;.right&#123; background: #f66; position: absolute;left: 210px;Right:0px;&#125; 元素隐藏方式（1）Opacity设置为0（2）visibility设置为hidden（3）display设为 none（4）position 设为 absolute 然后将位置设到不可见区域。（5）Clip-path]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域知识小结]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%B7%A8%E5%9F%9F%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么情况算是跨域？同ip（或domin），同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略开放了后门。例如img，script，style等标签，都允许跨域引用资源，然而，也只能是引用这些资源而已，并不能读取这些资源的内容。 为什么要有跨域的限制？访问端口号或域名或协议不同的url，就形成了跨域。如果没有跨域的限制，会存在CSRF(跨站脚本请求伪造)漏洞。防止CSRF攻击的方法:1.验证码2.referrer check3.token, 由于攻击者不能获得cookie(理论上), 因此发送请求的时候(post/get)带上token(其实就是伪随机数)。 JSONP的原理JSONP是一种跨域共享资源的方法。很多人会好奇JSONP和JSON是什么关系，JSONP是JSON with padding的缩写，即填充式JSON或参数式JSON，是被包含在函数调用中的JSON，如下面的样子：callback({“name”: “Chong”});JSONP是通过动态元素来实现的，使用时可以为src属性指定一个跨域URL。由于浏览器加载脚本是不受同源规则限制的，所以即使是跨域的URL同样可以发送请求。因为JSONP是有效的JavaScript代码，所以再请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。示例代码：function handleResponse(response){ alert(“您的IP地址是 “ + response.ip);}var script = document.createElement(“script”);script.src=”…?callback=handleResponse”;document.body.insertBefore(script, document.body.firstChild);所以总结一下JSONP的实现方式：1.向当前页面中动态插入一个元素，src属性设置为请求地址，并在地址中指定好回调函数2.js代码中预先定义好jsonp的回调函数3.请求完成后，会立即调用预先指定好的jsonp回调，并将数据以json的格式传递到回调中。4.JSONP之所以可以实现跨域，依赖的是下面的条件：浏览器请求脚本是不受同源规则限制的 元素加载完成的脚本会立即执行需要注意的是，JSONP是需要服务端配合的，因为JSONP返回的是一段代码。跨域请求资源有哪几种方式？他们的优缺点是什么？ 常见的跨域方式如下：JSONP，图像Ping，CORS，Web Sockets，postMessage，iframeJSONP优点：简单易用，浏览器支持好。缺点：1.JSONP是从其他域中加载代码并执行，所以存在很多安全隐患，如果其他服务器在响应中夹带恶意代码的话，没有办法防范。2.JSONP难以确定请求失败的情况。HTML5中给元素增加了一个onerror事件，但是还是有浏览器不支持。3.只能发送GET请求图像Ping这是指通过请求图片的方式来跨域发送请求。优点：简单，兼容性好，不需要服务器做针对性处理。缺点：1.只能单向通信，即客户端发送信号给服务端，无法接收到服务端的回复2.只能发送GET请求3.容易被浏览器缓存请求，导致请求发送不出去。CORSCORS是Cross-Origin Resource Sharing的缩写，即跨域资源共享。CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。优点：功能强大缺点：1.需要服务端来配合实现（其实很简单~）2.IE必须IE10以上WebSocket这个貌似就不用多说了，属于没用过也应该听过的一种技术。优点：1.双工通信，浏览器和服务器都可以发起请求2.通信效率高，一次链接可以复用，省去反复的握手环节缺点：1.实现上较为复杂，包括客户端和服务端2.浏览器支持问题localStorage 也存在跨域的问题（通过postMessage解决）CROS方法实现跨域当使用 XMLHttpRequest 发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头 origin，后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin，值就是发起请求的源地址(http://127.0.0.1:8888)，浏览器得到响应会进行判断 Access-Control-Allow-Origin 的值是否和当前的地址相同，只有匹配成功后才进行响应处理。在同源策略的限制下，如何加载静态css和js资源感觉这个问的就是跨域的方法而已, 面试官想要的答案应该是这个Cross-Origin Resource Sharing, 即跨域资源共享。CORS分为两种:简单请求GET, HEAD, POST, 注意，当是POST方法时，Content-Type只有为下列三个字段才算是简单请求。 text/plain multipart/form-data * application/x-www-form-urlencoded简单请求的过程：1.浏览器直接发送CORS请求，具体来说，就是在头部中，添加一个Origin字段。2.如果Origin指定的源，不在许可范围内，会报跨域。3.如果在的话，服务器会返回的响应，会多几个头部字段。Access-Control-Allow-OriginAccess-Control-Allow-Credentials, 表示是否允许发送cookieAccess-Control-Expose-Headers, 可选字段非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。AJAX跨域，有哪些解决方法，访问子域算不算跨域?在某些应用场景下，需要在主域中，调用子域中的某个接口，如果直接在主域中向子域发ajax请求，会报跨域错误，可以用iframe来解决这种跨域问题。在主域的A页面中要用iframe把B页面url地址引过来。123456789101112&lt;iframe id=&quot;iframe&quot; src=&quot;http://baike.baidu.com/B.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; $(function()&#123; try&#123; document.domain = &quot;www.baidu.com&quot;; &#125;catch(e)&#123;&#125; $(&quot;#iframe&quot;).load(function()&#123; var iframe = $(&quot;#iframe&quot;).contentDocument.$; ifram.get(&quot;http://baike.baidu.com/接口&quot;,function(data)&#123;&#125;); &#125;); &#125;);&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Promise学习小结]]></title>
    <url>%2F2018%2F09%2F15%2FPromise%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[用promise手写ajax123456789101112131415161718192021222324// ajax函数将返回Promise对象:function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125;var log = document.getElementById(&apos;test-promise-ajax-result&apos;);var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);p.then(function (text) &#123; // 如果AJAX成功，获得响应内容 log.innerText = text;&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码 log.innerText = &apos;ERROR: &apos; + status;&#125;); 什么是Promise？下面的回答很像在背概念，但是很精辟所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）传统的回调有五大信任问题：调用回调过早调用回调过晚（或没有被调用）调用回调次数过少或过多未能传递所需的环境和参数吞掉可能出现的错误和异常 Promise的解决办法：1.调用回调过早对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用。2.调用回调过晚（或没有被调用）对于一个Promise对象注册的每一个观察回调都是相对独立、互不干预的。而Promise对象调用resolve()和reject()时，每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用。此外，关于回调未调用。正常情况下，没有任何东西可以阻止Promise向你通知它的决议，即使你的JavaScript代码报错了，一会通过异常回调来捕获到。如果Promise永远不被决议的话，Promise本身已提供了竞态的抽象机制来作为解决方案。3.调用回调次数过少或过多Promise的定义方式使得它只能被决议一次。即使代码中出现多次决议，这个Promise也会接受第一次决议，并会忽略掉其他任何后续调用。所以任何通过then()注册的回调只会被调用一次。4.未能传递所需的环境和参数凡是被决议的值都会传递到观察回调中，如果没有显示的决议值也会传递一个undefined给观察回调。需要注意的是，Promise只允许传一个决议值，其他值将会被默默忽略掉。5.吞掉可能出现的错误和异常如果在创建Promise时，存在JavaScript代码错误，会直接导致该Promise的拒绝决议，那么你可以通过reject()来捕获异常，代码中的任何异常都不会吞掉。以上的回答十分的啰嗦，但是如果上面的五点你都能记住的话，你会了解很多关于Promise的细节问题，也会应对一些面试官的追问，如Promise的then()会不会被重复调用 等。Promise中的异步模式有哪些？有什么区别？好吧，这个问题可能会把面试者问懵……可以考虑另一种问法，或者直接进入下一个问题，说一说Promise.all()和Promise.race()的区别。因为ES6中的Promise中只有这两个模式all和race，其他的如first、any、last等都是其他Promise库提供的。回到问题本身，Promise.all()和Promise.race()的区别all会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。race会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？all会立即决议，决议结果是fullfilled，值是undefinedrace会永远都不决议，程序卡死……如何确保一个变量是可信任的Promise（Promise.resolve方法传入不同值的不同处理有哪些）可以通过Promise.resolve()方法对不确定的值进行Promise化，返回一个Promise对象。如果是一个立即值，如一个普通变量，那么该Promise会立即决议为成功。如果是一个Promise值，那么会将该Promise直接返回赋值给这个Promise，不会有额外开销。如果是一个类Promise值， 比如其中含有名称为then的成员变量，那么会将then展开形成一个新的Promise对象。Promise是如何捕获异常的？与传统的try/catch相比有什么优势？传统的try/catch捕获异常方式是无法捕获异步的异常的，代码如下：try { setTimeout(function(){ undefined(); //undefined不是一个方法，会抛出异常 }, 500)} catch(err){ //这里并不能捕获异常 console.log(err);}而对于Promise对象来说，构造Promise实例时的代码如果出错，则会被认为是一个拒绝的决议，并会向观察回调中传递异常信息。所以即使是一个异步的请求，Promise也是可以捕获异常的。此外，Promise还可以通过catch回调来捕获回调中的异常。Promise是一个不错异步操作解决方案，他解决了传统的通过回调和事件来解决异步操作的诸多问题，如“竞争”，回调信任度低的问题。ES6中也提供了标准的Promise供大家使用。如何解决异步回调地狱promise、generator、async/await有三个函数，内部实现都是异步的，怎么让这三个函数变成一个同步的，以节省时间promise.allPromise状态一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步与回调函数]]></title>
    <url>%2F2018%2F09%2F15%2FJavaScript%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。JavaScript实现异步的原理：首先，js是单线程的语言，即同一时间只能做一件事。Js的宿主环境（比如浏览器，node）是多线程的，宿主环境通过某种方式（事件驱动）使得js具备了异步的属性。浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript线程，UI渲染线程，浏览器事件触发线程。1、JavaScript引擎线程是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个js线程在运行js程序。2.UI渲染线程负责渲染浏览器页面，当界面需要重绘repaint或者由于某种操作引发回流reflow时，该线程就会执行。但注意UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起，UI更新会被保存在一个队列中，等到JS引擎空闲时立即被执行。3.事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的列尾，等待js引擎处理。这些事件可能来自js引擎当前执行代码块如setTimeOut、也可能来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于js的单线程关系，所有这些事件都得排队等JS引擎处理。总结：当js触发到异步任务时，会将异步任务交给浏览器进行执行，当有执行结果时，会把异步任务的回调插入待处理队列的队尾。注意：JS的工作机制是当前线程空闲的情况下才会执行异步代码的回调，即当所有同步任务执行完毕后才会执行异步任务的回调。AJAX发送异步请求时浏览器做了什么？1.JS创建了一个AJAX请求2.浏览器另外开启了一个AJAX引擎线程，执行ajax请求3.执行得到响应后将回调函数放入任务队列中4.Js执行任务队列中的回调函数有哪些常见的异步回调函数？点击事件，ajax请求，定时器浏览器处理点击事件的过程浏览器开启事件触发线程，等待用户动作，事件触发线程解析为响应事件，转移到js引擎线程，排队等候js引擎的处理。如何实现js的多线程操作：html5的web worker]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX学习小结]]></title>
    <url>%2F2018%2F09%2F15%2FAJAX%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AJAX在jquery底层如何实现12345678910$.ajax(&#123; &quot;url&quot;:&quot;&quot;, //访问路径 &quot;data&quot;:&quot;&quot;, // 需要传输的数据 &quot;type&quot;:&quot;&quot;, // 请求方式 &quot;dataType&quot;:&quot;&quot;, // 返回值类型 &quot;success&quot;:function(obj)&#123;&#125;, // 响应成功时的回调函数 &quot;error&quot;:function(obj)&#123;&#125; // 响应失败时的回调函数&#125;);$.get(URL,callback);$.post(URL,data,callback); 用原生JS实现一个接口，能够用Ajax上传文件并显示上传进度，上传完成后接收一个来自服务器的json数据12345678910111213141516171819202122var xhr = new XMLHttpRequest(); xhr.open(&apos;POST&apos;, &apos;url&apos;); // 上传完成后的回调函数 xhr.onreadystatechange = function() &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;上传出错&apos;); &#125; &#125;; // 获取上传进度 xhr.upload.onprogress = function(event) &#123; console.log(event.loaded) console.log(event.total) if (event.lengthComputable) &#123; var percent = Math.floor(event.loaded / event.total * 100); document.querySelector(&quot;#progress .progress-item&quot;).style.width = percent + &quot;%&quot;; // 设置进度显示 console.log(percent) &#125; &#125;; xhr.send(fd); 请简述 AJAX 及基本步骤？简述 AJAX：AJAX即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 Ajax应用场景Ajax的特点在于异步交互，动态更新web页面，因此它的适用范围是交互较多，频繁读取数据的web应用。场景1. 用Ajax进行数据验证场景2.按需取数据场景3.自动更新页面 AJAX的优点 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。AJAX的缺点1.ajax不支持浏览器back按钮。2.安全问题 AJAX暴露了与服务器交互的细节。3.对搜索引擎的支持比较弱。4.破坏了程序的异常机制。5.不容易调试。6.跨域请求有一定限制。解决方式：jsonp。readyState属性状态有5个可取值： 0=未初始化 ，1=正在加载 2=已加载，3=交互中，4=完成AJAX请求中，readyStatus的状态有哪些0: 未打开, open()方法未调用。1: 未发送, send()方法未调用。2: 已获取响应头, send()方法已被调用，响应头和响应状态已经返回。3: 正在下载响应体, responseText已经获取了部分数据。4: 请求完成，整个请求过程结束了。AJAX 基本步骤：//初始化ajax对象var xhr = new XMLHttpRequest();//连接地址，准备数据xhr.open(“方式”,”地址”,是否为异步);//接收数据完成触发的事件xhr.onload =function(){}//发送数据xhr.send();AJAX的交互模型ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器担负的工作转移到客户端，便于客户端资源来出来，减轻服务器和带宽的负担。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习]]></title>
    <url>%2F2018%2F09%2F15%2FjQuery%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jQuery的优点jQuery的优点 轻量级：大小在30KB左右 强大的选择器：支持几乎所有的css选择器 出色的DOM操作的封装： 可靠的事件处理机制 完善的ajax 不污染顶级变量：只建立一个名为jQuery的对象，其所有的函数方法都在这个对象之下 出色的浏览器兼容性 链式操作方式 隐式迭代：当用jQuery找到带有”.myClass”类的全部元素，然后隐藏他们时，无需遍历每一个返回的元素。相反，jQuery里的方法都被设计成自动操作对象的集合，而不是单独的对象，这使得大量的循环结构变得不再必要，从而大幅的减少了代码量。 丰富的插件支持、完善的文档、开源 导航栏$(document).ready()网页中所有的dom元素都加载完毕后执行，可能dom相关联的东西并没有加载完，能同时编写多个1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;box&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; $(&quot;.level1&gt;a&quot;).click(function)&#123; $(this).addClass(&quot;current&quot;) .next().show(); .parent.siblings().children(&apos;a&apos;).removeClass(&apos;current&apos;); .next().hide(); return false; &#125;&lt;/script&gt; DOM对象和jQuery对象在jQuery对象中无法使用dom对象的任何方法jQuery对象写法：var $variable= jQuery 对象DOM对象写法：var variable= DOM对象 jQuery对象是一个类似数组的对象有两种方法可以将jQuery对象转换成dom对象，即[index]和get[index]var $cr=$(“#cr”);var cr=$cr[0];var cr=$cr.get(0); dom对象转成jQuery对象只需要用$()把dom对象包装起来var cr=document.getElementById(“cr”);var $cr=$(cr);$()函数就是一个jQuery对象的制造工厂 jQuery库中，几乎所有的插件都被限制在它的命名空间里。通常，全局对象都被很好的存储在jQuery命名空间里。 jQuery选择器jQuery选择器的优势简洁的写法支持CSS1到CSS3选择器完善的处理机制$(‘#tt’).css(“color”,”red”);//这里无需判断$(‘#tt’)是否存在$(‘#tt’)获取的永远是对象，即使网页上没有此元素要用jQuery检查某元素是否在网页上存在，需要获取元素的长度来判断，或者转换成dom对象来判断 ##jQuery选择器 基本选择器 #id.classelement*div,span,p.myClass 层次选择器div span //所有子元素div&gt;span //直接子元素.one+div //class为one的下一个div同辈元素pre~siblings //选取pre之后的所有siblings元素 过滤选择器:firstdiv:last //选取div元素中，最后一个div元素input:not(.myClass) //选取class不是myClass的input元素:even:oddinput:eq(index) //选取索引值等于index的input元素:gt(index) //选取索引值大于index的input元素:animated:focus 内容过滤选择器:contains(text):empty //选取不含子元素或者文本的空元素:has(selector):parent //选取含有子元素或者文本的元素 可见性过滤选择器:hidden:visible[attribute=value] 子元素过滤选择器:nth-child(3n) //索引n从1开始的，选取索引值是3的倍数的元素:first-child:only-child:last-child 表单对象属性过滤选择器:enable:disable:checked:selected 表单选择器:input:radio:checkbox:button:text:password jQuery中的dom操作1.DOM CoregetElementById()2.HTML-DOMdocument.formsdocument.src3.CSS-DOMelement.style.color=”red”; 创建节点var $li=$(“香蕉“);$(“ul”).append($li); 插入节点append();appendTo();prepend();prependTo();after();insertAfter();before();insertBefore(); 删除节点remove()detach()empty() jquery与ajaxajax全称为 asynchronous JavaScript and xml ajax的优势 不需要插件支持：被大多数浏览器支持 优秀的用户体验：在不刷新整个页面的前提下更新数据 提高web程序性能：在传统模式中，数据提交通过form表单来实现，而数据的获取靠全页面刷新来重新获取整夜的内容，ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送。 减轻服务器和带宽的负担：ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器担负的工作转移到客户端，便于客户端资源来出来，减轻服务器和带宽的负担。 ajax的缺点破坏了浏览器前进、后退按钮的正常功能对搜索引擎的支持不足 ajax实现ajax的核心是XMLHttpRequest对象，它是实现的关键–发送异步请求、接受响应及执行回调都是通过它来完成。1234567891011121314151617181920212223242526// 异步检查用户名是否存在function checkUsername(username) &#123; // 获取XMLHttpRequest对象 var xhr = new XMLHttpRequest(); var url = &quot;check_username.do?username=&quot; + username; // 配置onreadystatechange xhr.onreadystatechange = function() &#123; // 当服务器已经响应(4)且响应码是200时 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 根据服务器的响应，显示响应的提示消息 if (xhr.responseText == &quot;1&quot;) &#123; // 表示用户名存在 document.getElementById(&quot;username_hint&quot;).innerHTML= &quot;用户名正确&quot;; &#125; else &#123; // 表示用户名不存在 document.getElementById(&quot;username_hint&quot;).innerHTML= &quot;用户名不存在&quot;; &#125; &#125; &#125;; // 调用函数 xhr.open(&quot;GET&quot;, url, true); xhr.send();&#125; jquery中ajax的实现1234567891011$.ajax(&#123; &quot;url&quot;:&quot;&quot;, //访问路径 &quot;data&quot;:&quot;&quot;, // 需要传输的数据 &quot;type&quot;:&quot;&quot;, // 请求方式 &quot;dataType&quot;:&quot;&quot;, // 返回值类型 &quot;success&quot;:function(obj)&#123;&#125;, // 响应成功时的回调函数 &quot;error&quot;:function(obj)&#123;&#125; // 响应失败时的回调函数&#125;);$.get(URL,callback);$.post(URL,data,callback); get、post方法的区别：（1） get是从服务器上获取数据，post是向服务器传送数据。（2） get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。（3） get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。（4） get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 使用Ajax时的返回值类型有哪些？xml、html、script、JSON、jsonp、textxml：返回XML文档，可用 jQuery 处理。html：返回纯文本HTML信息；script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了 “cache” 参数；json：json方式和html方式在请求和服务器中完全是一样，请求的返回值实际上都是String对象，有两点不同，第一：html方式的时候并没有限制返回的字符串格式，而json方式的时候，必须符合json协议的规范。第二：html方式请求完成之后没有做任何的操作直接回调sucuess，而json多了一步就是加了eval，执行返回的字符串，看看源码data = eval_r(“(“ + data + “)”);返回json对象；(方法的返回值是Javabean时，在响应体中响应成json字符串格式)jsonp：jsonp方式的交互方式和js是一样的，本身xmlHttpRequest对象并不能跨域访问，但是script标签的src可以跨域访问，这里就注意两个概念：第一Ajax是不能跨域操作的，第二jQuery的jsonp是可以跨域操作，jsonp到底是什么东西呢？他是一个非官方的定义，目前的规范，需要服务器和客户端进行配合使用；text：返回纯文本字符串。 jQuery的ajax返回值是什么？jQuery中的ajax大家很常用，以至于绝大部分人把他认为是“理所应当”，而忽略了他的底层逻辑和实现原理。$.ajax()方法返回的是一个延迟对象，即$.Deferred的实例。所以你可以像下面这样使用$.ajax()方法`//利用done()和fail()方法来处理ajax请求$.ajax({ url:”http://mydomain.com/memberInfo/get&quot;, async: false}).done(responseData =&gt; { console.log(responseData)}).fail(()=&gt;{ console.error(‘出错了！’)}) jquery和jquery.fn有什么区别，方法是写在哪里的ajax在jquery底层如何实现fn 是什么东西呢。查看jQuery代码，就不难发现。jQuery.fn = jQuery.prototype = { init: function( selector, context ) {//…. //……};原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript没有明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用语句$(“#btn1″) 会生成一个 jQuery类的实例。jQuery.extend(object);为jQuery类添加添加类方法，可以理解为添加静态方法。如：$.extend({ add:function(a,b){return a+b;}});便为jQuery添加一个为add的“静态方法”，之后便可以在引入jQuery的地方,使用这个方法了，$.add(3,4); //return 7jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax在jQuery中的实现]]></title>
    <url>%2F2018%2F09%2F12%2FAJAX%E5%9C%A8jQuery%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[通过ajax动态的加载或关闭协议，但每次点击都发送请求1234&lt;button id=&quot;trigger&quot;&gt;协议&lt;/button&gt;&lt;div style=&quot;display: none;&quot; id=&quot;card&quot;&gt;&lt;/div&gt;var trigger=$(&apos;#trigger&apos;);var card=$(&apos;#card&apos;); 1234trigger.on(&apos;click&apos;,function()&#123; card.load(&apos;card.html&apos;); card.toggle();&#125;); 用load状态来判断是否加载过，加载过就不重新加载 12345678910111213141516171819202122232425262728293031323334353637var load=false;trigger.on(&apos;click&apos;,function()&#123; if(card.is(&apos;:visible&apos;))&#123; card.slideUp(); &#125;else&#123; if(!load)&#123; card.load(&apos;card.html&apos;); load=true; &#125; card.slideDown(); &#125;&#125;);var form=$(&apos;#search&apos;);var input=$(&apos;input#username&apos;);var result=$(&apos;#result&apos;);var username;form.on(&apos;submit&apos;,function(e)&#123; e.preventDefault(); username=input.val(); $.ajax(&apos;https://api.github.com/users/&apos;+username) .done(function(data)&#123; var html=&apos;&lt;div&gt;用户名：&apos;+data.login+&apos;&lt;/div&gt;&apos; &apos;&lt;div&gt;介绍：&apos;+data.bio||&apos;无&apos;+&apos;&lt;/div&gt;&apos;; result.html(html); &#125;)&#125;)$.ajax(&apos;url&apos;,&#123; method:&apos;post&apos;, data:&#123; username:&apos;dd&apos;, password:&apos;1212&apos; &#125;, success:function(data)&#123;&#125;, error:function(data)&#123;&#125;,&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习]]></title>
    <url>%2F2018%2F09%2F11%2FES6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ES6解释ECMA是标准，JavaScript是实现类似于HTML5是标准，IE10，Chrome等是实现低版本浏览器主要支持ES3.1高级浏览器正在从ES5向ES6过渡 ES6兼容性ES6 IE10+，Chrome，移动端，Node.js 编译，转换： 在线转换：每次都需要加载，影响性能引入browser.js 提前编译：Babel ES6主要内容： 变量 函数 数组 字符串 面向对象 Promise generator 模块化 变量let和constvar缺点： 可以重复声明 无法限制修改 没有块级作用域 {}let const 不能重复声明，块级作用域const 不能修改，声明和赋值必须同时进行1234567891011121314151617181920212223242526&lt;input type=&quot;button&quot; value=&quot;按钮1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮2&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮3&quot;&gt;&lt;script&gt; var aBtn=document.getElementsByTagName(&apos;input&apos;); //打印全是3，要用闭包的方式解决 // for(var i=0;i&lt;aBtn.length;i++)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125; //封一个立即执行函数 // for(var i=0;i&lt;aBtn.length;i++)&#123; // (function(i)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125;)(i); // &#125; //使用let块级作用域 for(let i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick=function()&#123; alert(i); &#125; &#125;&lt;/script&gt; 箭头函数function name(){}()=&gt;{}去掉function，加一个=&gt;12345let arr=[12,45,778,45,4,77];arr.sort(function(a,b)&#123; return a-b;&#125;)arr.sort((a,b)=&gt;&#123;return a-b;&#125;); 如果只有一个参数，()可以省 如果只有一个return，{}可以省let show=a=&gt;a*2;show(5); 函数的参数参数的扩展/数组的展开收集剩余参数,rest parameter必须是最后一个 function show(a,b,...args){} 展开数组 展开后的效果，跟直接把数组的内容写在这儿一样 123let arr1=[1,2,3]; //...arr1等价于1,2,3let arr2=[4,5,6];arr=[...arr1,...arr2]; 默认参数1234function show(a,b=12,c=1)&#123; console.log(a,b,c);&#125;show(12,45,88); 解构赋值 左右两边必须结构一样 右边必须是个东西 声明和赋值不能分开let [a,b,c]=[21,23,’faf’];let {a,b,c}={a:12,b:’nn’,c:45}; 数组map,reduce,filter,foreach map 映射 一个对一个，进去多少出来多少123let arr=[12,66,69,44];let result1=arr.map(items=&gt;items*2);let result2=arr.map(item=&gt;item&gt;=60?&apos;及格&apos;:&apos;不及格&apos;); reduce 汇总 一堆出来一个123let result3=arr.reduce(function(temp,item,index)&#123; return temp+item;&#125;); 在reduce里求平均数1234567let result4=arr.reduce(function(temp,item,index)&#123; if(index!=arr.length-1)&#123; return temp+item; &#125;else&#123; return (temp+item)/arr.length; &#125;&#125;); filter 过滤器 forEach 迭代123456789let result5=arr.filter(item=&gt;item%3==0);let arr2=[ &#123;title:&apos;男士皮鞋&apos;,price:198&#125;, &#123;title:&apos;女士皮鞋&apos;,price:19800&#125;, &#123;title:&apos;男士皮包&apos;,price:198&#125;, &#123;title:&apos;女士皮包&apos;,price:19800&#125;];let result6=arr2.filter(json=&gt;json.price&gt;10000);let result7=arr.forEach((item,index)=&gt;&#123;alert(index+&apos;:&apos;+item)&#125;); 字符串多了两个新方法 startsWith,endsWith(根据后缀名显示图标)返回布尔值1234let str=&apos;http://it.kaikeba.com&apos;;if(str.startsWith(&apos;http://&apos;))&#123; alert(&apos;普通网址&apos;);&#125; 模板字符串 ES6的面向对象123456789101112class User&#123; constructor(name,pass)&#123; this.name=name; this.pass=pass; &#125; showName()&#123; alert(this.name); &#125; showPass()&#123; alert(this.pass); &#125;&#125; 新继承:12345678910111213141516171819202122232425262728293031class VipUser extends User&#123; constructor(name,pass,level)&#123; super(name,pass); this.level=level; &#125; showLevel()&#123; alert(this.level); &#125;&#125;var v1=new VipUser(&apos;blue&apos;,123,4);function User(nane,pass)&#123; this.name=name; this.pass=pass;&#125;User.prototype.showName=function()&#123; alert(this.name);&#125;User.prototype.showPass=function()&#123; alert(this.pass);&#125;function VipUser(name,pass.level)&#123; User.call(this,name,pass); this.level=level;&#125;VipUser.prototype=new User();VipUser.prototype.construstor=VipUser;VipUser.prototype.showLevel=function()&#123; alert(this.level);&#125; 面向对象应用-reactjson-json对象let str=’{“a”:”rr”,”b”:5}’;JSON.stringfy(str);-json简写 名字跟值一样的留一个就行 方法可以不要 :function json的标准写法： -只能用双引号 -所有的名字都必须用引号包起来 Promisegenerator生成器函数在中间暂停，踹一步走一步12345678function *show()&#123; alert(&apos;a&apos;); yield;//放弃 alert(&apos;b&apos;);&#125;let genObj=show();genObj.next();genObj.next(); yield可以传参，也可以返回123456789function *show()&#123; alert(&apos;a&apos;); let c=yield;// alert(&apos;b&apos;); alert(c);&#125;let genObj=show();genObj.next(12);//第一个没法给yield传参genObj.next(5); Promise适合一次读一堆generator适合逻辑性 koa实例123456789const koa=require(&apos;koa&apos;);//引入另一个模块const mysql=require(&apos;koa-mysql&apos;);mysql.createPool(&#123;host:&apos;localhost&apos;,user:&apos;root&apos;,password:&apos;123456&apos;,database:&apos;20070114&apos;&#125;);let server=new koa();server.use(function *()&#123; yield db.query(&apos;EELECT * FROM user_table&apos;); this.body=data;&#125;);server.listen(8080); ES7总结数组 includes 数组中是否包含某个东西 数组 JSON for...in 下标key key for...of 值value 错误 JSON不是一个迭代器，for...of不能用于json 数组 keys/values/entries 配合for...of使用，现浏览器不是很支持 keys=&gt;所有的key拿出来 values=&gt;所有的values拿出来 entries=&gt;所有的key-values对拿出来 求幂:3**8不需要runner12345async function readData()&#123; let data1=await $.ajax(&#123;url:&apos;data/1.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/2.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/3.txt&apos;,dataType:&apos;json&apos;&#125;);&#125; 字符串扩展includes(),startsWith(),endsWith()padStart()头部补全,padEnd()尾部补全proxy用于修改某些操作的默认行为，等同于在语言层面作出修改12345678910var user=new Proxy(&#123;&#125;,&#123; get:function(obj,prop)&#123; switch(prop)&#123; case &apos;full_name&apos;:return obj.fname+&apos; &apos;+obj.lname; &#125;, set:function(obj,prop)&#123; switch() &#125;&#125;&#125;)]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学promise]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%88%9D%E5%AD%A6promise%2F</url>
    <content type="text"><![CDATA[同步：同时只能做一件事异步：操作与操作之间没有关系，可以同时进行多个操作 异步：会让代码变得更复杂同步：代码简单 例如淘宝网各个小版块数据读取,这种回调很繁琐1234567891011121314151617ajax(&apos;/banner&apos;,function(banner_data)&#123; ajax(&apos;/hotitems&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;);&#125;,function()&#123; alert(&apos;读取失败&apos;);&#125;); 同步:（假设有这种同步的ajax）1234let banner_data=ajax_async(&apos;baners&apos;);let hotitems_data=ajax_async(&apos;hotitems&apos;);let banners_data=ajax_async(&apos;baners&apos;);let banners_data=ajax_async(&apos;baners&apos;); promise：消除异步操作（同同步一样的方式，书写异步代码）Promise.all 全部要成功Promise.race 竞速，有一个成功就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //resolve成功了，reject失败了 function createPromise(url)&#123; return new Promise(function(resolve,reject)&#123; $.ajax(&#123; url, dataType:&apos;json&apos;, success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;); &#125;); &#125; // p.then(function(arr)&#123; // let [res1,res2]=arr; // alert(&apos;成功了&apos;); // &#125;,function()&#123; // alert(&apos;失败了&apos;); // &#125;) Promise.all([ createPromise(&apos;arr.txt&apos;), createPromise(&apos;json.txt&apos;) ]).then(function(arr)&#123; let [res1,res2]=arr; alert(&apos;全部都成功了&apos;); &#125;,function()&#123; alert(&apos;至少有一个失败了&apos;); &#125;); //jQuery自带promise,$.ajax(...)返回一个promise对象 Promise.all([ $.ajax(&#123;url:&apos;arr.txt&apos;,dataType:&apos;json&apos;&#125;), $.ajax(&#123;url:&apos;json.txt&apos;,dataType:&apos;json&apos;&#125;), ]).then(function(results)&#123; let [arr,json]=results; alert(&apos;成功了&apos;); console.log(arr,json); &#125;,function()&#123; alert(&apos;失败了&apos;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue初学之创建点赞组件]]></title>
    <url>%2F2018%2F09%2F06%2Fvue%E5%88%9D%E5%AD%A6%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%82%B9%E8%B5%9E%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习如何创建一个vue组件 12345678910111213141516171819202122232425262728293031Vue.component(&apos;likes&apos;,&#123; //创建模板 template: `&lt;button v-bind:class=&quot;&#123;liked:liked&#125;&quot; @click=&quot;toggleLike&quot;&gt; 赞 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;`, //存储赞的数量和是否已点赞的状态 data:function()&#123; return &#123; like_count:13, liked:false &#125; &#125;, methods:&#123; toggleLike:function()&#123; //如果未点赞，赞数加一，然后更改点赞状态 if(this.liked==false)&#123; this.like_count++; this.liked=true; &#125;else&#123; //如果已点赞，赞数减一，然后更改点赞状态 this.like_count--; this.liked=false; &#125; &#125; &#125;&#125;);//必须new一下，绑定元素new Vue(&#123; el:&apos;#app&apos;,&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷方式]]></title>
    <url>%2F2018%2F09%2F06%2Fsublime%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[sublime常用快捷键 Ctrl + / —————-注释 Ctrl + P —————-打开命令行进行模糊匹配，来查找文件 Ctrl + Shift +V ———-粘贴过程中保持缩进 Alt + F3 —————–选中选择的词，用来多行同时填写（或重写） Ctrl + H —————–替换 Ctrl + W —————关闭当前文档 Ctrl + D —————多行游标选择可以搭配 Ctrl + K取消选择部分游标产生游标的另外一种方式，按住Shift + 鼠标右键拖动光标 Ctrl + Shift + D ———复制这行文本]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript加载时间线]]></title>
    <url>%2F2018%2F09%2F05%2FJavaScript%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JavaScript加载时间线 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段 document.readyState = ‘loading’ 。 遇到link外部css，创建线程加载，并继续解析文档。 遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。（禁止使用document.write()） 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 当文档解析完成，document.readyState = ‘interactive’ 。 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（禁止使用document.write()）; document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。 从此，以异步响应方式处理用户输入、网络事件等。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
