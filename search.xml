<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浮动与布局]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[浮动与布局负边距与浮动布局所谓的负边距就是margin取负值的情况，如margin:-100px，margin:-100%。当一个元素与另一个元素margin取负值时将拉近距离。常见的功能如下： 向上移动当多个元素同时从标准流中脱离开来时，如果前一个元素的宽度为100%宽度，后面的元素通过负边距可以实现上移。当负的边距超过自身的宽度将上移，只要没有超过自身宽度就不会上移。1234567891011121314151617 #div1 &#123; height: 100px; background: lightblue; width: 100%; float: left; &#125; #div2 &#123; height: 100px; background: lightgreen; width: 30%; float: left; margin-left: -100%; &#125;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;/body&gt; 去除列表右边框开发中常需要在页面中展示一些列表，如商品展示列表等，如果我们要实现如下布局：1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; #div1 &#123; width: 780px; margin: 0 auto; border: 3px solid lightblue; overflow: hidden; margin-top: 10px; &#125; .box &#123; width: 180px; height: 180px; margin: 0 20px 20px 0; background: lightgreen; float: left; &#125;#div2&#123; margin-right: -20px; margin-bottom: -20px; overflow: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;div id=”div2”&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 圣杯布局12345678910111213141516171819202122232425262728293031323334 &lt;style type=&quot;text/css&quot;&gt; .container &#123; padding: 0 300px 0 200px; //左右各剩余了一块区域 &#125; .left, .main, .right &#123; position: relative; min-height: 130px; float: left; &#125; .left &#123; left: -200px; margin-left: -100%; background: green; width: 200px; &#125; .right &#123; right: -300px; margin-left: -300px; background-color: red; width: 300px; &#125; .main &#123; background-color: blue; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 在不增加额外标签的情况下，圣杯布局已经非常完美，圣杯布局使用了相对定位，以后布局是有局限性的，而且宽度控制要改的地方也多。在淘宝UED（User Experience Design）探讨下，增加多一个div就可以不用相对布局了，只用到了浮动和负边距，这就是我们所说的双飞翼布局。 双飞燕布局123456789101112131415161718192021222324252627282930&lt;style type=&quot;text/css&quot;&gt; #center, #left, #right &#123; height: 100%; float: left; &#125; #center &#123; width: 100%; background: lightgreen; &#125; #right &#123; background: lightblue; width: 20%; margin-left: -20%; &#125; #left &#123; background: lightcoral; width: 20%; margin-left: -100%; &#125; #main-inner &#123; padding-left: 20%; &#125;&lt;/style&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;center&quot;&gt; &lt;div id=&quot;main-inner&quot;&gt; center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt; left &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; right&lt;/div&gt; &lt;/div&gt; Flex布局：可以简便、完整、响应式地实现各种页面布局。弹性布局，任何一个容器都可以指定为Flex布局，display: flex。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex主要解决两个问题：元素位置：由6个容器属性和2个项目属性控制6个容器属性 flex-direction （项目的排列方向）row 默认值，排成一行| row-reverse | column | column-reverse项目的排列方向 flex-wrap nowrap（默认）：不换行 | wrap | wrap-reverse; flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content flex-start （默认值）：左对齐| flex-end右对齐 | center 居中| space-between两端对齐 | space-around每个项目两侧的间隔相等; align-items 项目在交叉轴上如何对齐 align-content 定义了多根轴线的对齐方式2个项目属性 Order 项目的排列顺序 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 元素尺寸或自适应能力：由4个项目属性控制flex-grow 能分配到空间比例，属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 收缩比率，默认为1，即如果空间不足，该项目将缩小。 flex-basis 伸缩基准值，属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 Flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。 用flex实现圣杯布局1234567891011121314151617&lt;style&gt; .flex-box&#123; display: flex; height:200px; width:100%; background:red; &#125; .item:nth-child(2)&#123; flex:1; background:red; &#125; &lt;/style&gt;&lt;div class=&quot;flex-box&quot;&gt;&lt;div class=&quot;item&quot; style=&quot;width:200px;background:yellow&quot;&gt;左&lt;/div&gt;&lt;div class=&quot;item&quot;&gt; 中&lt;/div&gt;&lt;div class=&quot;item&quot; style=&quot;width:200px;background:yellow&quot;&gt;右&lt;/div&gt;&lt;/div&gt; 我们left和right设置了固定的宽度，然后将flex-basis设置为0，使得容器的剩余空间仅为容器总宽度减去left和right的宽度，不减去center本身内容的宽度，我们的剩余空间是包括减去自身内容宽度后的宽度；然后设置flex-grow和flex-shrink设置为1，将剩余的宽度全部分配给自己，不管宽度是有剩余还是溢出，也达到了自适应的要求。 CSS3多列布局模块CSS3为了满足这个要求增加了多列布局模块，如果需要实现多列布局模块先看看这几个CSS3属性：column-count: 3; /分3栏/column-gap: 40px; /栏间距/column-rule: 2px solid lightgreen; /栏间分隔线/ 解决由于浮动产生的高度坍塌float 会尽量靠上尽量靠左（右），对父级元素产生影响，高度会塌陷。我们经常会遇到一种情况，给一个元素设置浮动之后 float:left/right;，如果该元素的父元素有背景颜色，那么会发现父元素的背景颜色消失了；如果父元素有一个边框，那么浮动元素无法将边框撑开。元素浮动后，就不在整个文档流的管辖范围，那么它之前存在在父元素内的高度就随着浮动不复存在了，而此时父元素会默认自己里面没有任何内容（前提是未给父元素设置固定高度，如果父元素本身有固定高度，就不会出现这种情况）解决方法：1、给父元素也添加float。这样让父元素与子元素一起脱离文档流浮动起来，保证子元素在父元素内，这样父元素就能自适应子元素的高度，但是此方法有一弊端，一定会影响父元素之后的元素排列，甚至影响布局。2、给父元素一个固定高度，此方法适用于子元素高度已知并且固定的情况。3、添加一个块级元素，并给此元素设置clear:both;清除浮动。在很早之前用的就是这种解决办法，新建一个空的div，为这个div设置clear：both；这样无疑是增加了无意义的标签，一个大型页面中，这种标签太多是不好的。4、给父元素添加 overflow：hidden；5、通过伪类::after清除浮动 垂直居中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667(1)margin:auto法div&#123; width: 400px; height: 400px; position: relative; border: 1px solid #465468; &#125; img&#123; position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125;&lt;div&gt; &lt;img src=&quot;mm.jpg&quot;&gt;&lt;/div&gt;定位为上下左右为0，margin：0可以实现脱离文档流的居中.(2)margin负值法.container&#123; width: 500px; height: 400px; border: 2px solid #379; position: relative;&#125;.inner&#123; width: 480px; height: 380px; background-color: #746; position: absolute; top: 50%; left: 50%; margin-top: -190px; /*height的一半*/ margin-left: -240px; /*width的一半*/ &#125;补充：其实这里也可以将marin-top和margin-left负值替换成， transform：translateX(-50%)和transform：translateY(-50%)(3)table-cell（未脱离文档流的）设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。div&#123; width: 300px; height: 300px; border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;&#125;img&#123; vertical-align: middle;&#125;(4)利用flex将父元素设置为display:flex，并且设置align-items:center;justify-content:center;.container&#123; width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; &#125; .inner&#123; border: 3px solid #458761; padding: 20px; &#125; width与height设置的百分比是相对谁来计算的？padding与margin呢？一、font-size当前的字体大小等于100%二、line-heightline-height的计算值就是当前字体的值乘以该百分比。三、width正常文档流中和设置浮动的情况下，相对于父元素content-box的宽度；绝对定位时，相对于包含块padding-box的宽度。四、heightheight对百分比也是支持的，但是其和width还是有一个明显的区别：当父元素width属性为auto时，子元素宽度仍然可以使用百分比设置。但是对于height，只要子元素还是在正常文档流当中的，如果父元素的height属性为auto，则子元素height设置为百分比会被忽略。规范中指出：如果包含块的高度没有显式指出（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto。而auto*100/100=NaN。所以，若要高度的百分比设置有效，需要如下设置：html,body{ height:100%}上述高度计算，都是对于正常流。五、margin、padding无论是垂直或水平方向，均是相对于父元素的宽度，正常文档流中和设置浮动的情况下，相对于父元素content-box的宽度；绝对定位时，相对于包含块padding-box的宽度。七、定位元素的left/right/bottom/top百分比值 top,bottom设置百分比定位是按包含块padding-box的高度来计算的，同样left,right,设置百分比定位是按包含块padding-box的宽度来计算的。请问你了解vm vh这个单位吗？vw : 1vw 等于视口宽度的1%vh : 1vh 等于视口高度的1%如何居中div,如何居中一个浮动元素?给div设置一个宽度，然后添加margin:0 auto属性设置容器的浮动方式为相对定位 确定容器的宽高 宽500 高 300 的层 设置层的外边距 .Div { Width:500px ; height:300px; Margin: -150px 0 0 -250px; position: absolute; left:50%; top:50%;} display block 象块类型元素一样显示。 none 此元素不会被显示。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示(受到width和height的影响，但不单独占满一行)。 list-item 象块类型元素一样显示，并添加样式列表标记。 positionabsolute 生成绝对定位的元素，相对于具有定位属性（static以外的）第一个父元素进行定位。fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。relative 生成相对定位的元素，相对于其正常位置进行定位。static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。inherit 规定应该从父元素继承 position 属性的值。Sticky 兼容性 CSS3的position的新值: sticky, 它是relative和fixed的组合体，然后可以设置top, left, bottom, right为阀值, 超过阀值以relative表现，小于阀值以fixed表现。 左边定宽右边自适应的两列布局12345678910111213141516171819202122232425262728293031323334353637 1、浮动.left &#123; float: left; width: 100px;&#125;.right &#123; margin-left: 110px;&#125;2、flex.parent &#123; display: flex;&#125;.left &#123; width: 100px; margin-rigth: 100px;&#125;.right &#123; flex: 1;&#125;3、position:absolute.content&#123; position: relative; width: 100%; height: 500px; border: 1px solid #000;&#125;.left&#123; background:#fcc; width: 200px; position: absolute;&#125;.right&#123; background: #f66; position: absolute;left: 210px;Right:0px;&#125; 元素隐藏方式（1）Opacity设置为0（2）visibility设置为hidden（3）display设为 none（4）position 设为 absolute 然后将位置设到不可见区域。（5）Clip-path]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域知识小结]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%B7%A8%E5%9F%9F%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么情况算是跨域？同ip（或domin），同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略开放了后门。例如img，script，style等标签，都允许跨域引用资源，然而，也只能是引用这些资源而已，并不能读取这些资源的内容。 为什么要有跨域的限制？访问端口号或域名或协议不同的url，就形成了跨域。如果没有跨域的限制，会存在CSRF(跨站脚本请求伪造)漏洞。防止CSRF攻击的方法:1.验证码2.referrer check3.token, 由于攻击者不能获得cookie(理论上), 因此发送请求的时候(post/get)带上token(其实就是伪随机数)。 JSONP的原理JSONP是一种跨域共享资源的方法。很多人会好奇JSONP和JSON是什么关系，JSONP是JSON with padding的缩写，即填充式JSON或参数式JSON，是被包含在函数调用中的JSON，如下面的样子：callback({“name”: “Chong”});JSONP是通过动态元素来实现的，使用时可以为src属性指定一个跨域URL。由于浏览器加载脚本是不受同源规则限制的，所以即使是跨域的URL同样可以发送请求。因为JSONP是有效的JavaScript代码，所以再请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。示例代码：function handleResponse(response){ alert(“您的IP地址是 “ + response.ip);}var script = document.createElement(“script”);script.src=”…?callback=handleResponse”;document.body.insertBefore(script, document.body.firstChild);所以总结一下JSONP的实现方式：1.向当前页面中动态插入一个元素，src属性设置为请求地址，并在地址中指定好回调函数2.js代码中预先定义好jsonp的回调函数3.请求完成后，会立即调用预先指定好的jsonp回调，并将数据以json的格式传递到回调中。4.JSONP之所以可以实现跨域，依赖的是下面的条件：浏览器请求脚本是不受同源规则限制的 元素加载完成的脚本会立即执行需要注意的是，JSONP是需要服务端配合的，因为JSONP返回的是一段代码。跨域请求资源有哪几种方式？他们的优缺点是什么？ 常见的跨域方式如下：JSONP，图像Ping，CORS，Web Sockets，postMessage，iframeJSONP优点：简单易用，浏览器支持好。缺点：1.JSONP是从其他域中加载代码并执行，所以存在很多安全隐患，如果其他服务器在响应中夹带恶意代码的话，没有办法防范。2.JSONP难以确定请求失败的情况。HTML5中给元素增加了一个onerror事件，但是还是有浏览器不支持。3.只能发送GET请求图像Ping这是指通过请求图片的方式来跨域发送请求。优点：简单，兼容性好，不需要服务器做针对性处理。缺点：1.只能单向通信，即客户端发送信号给服务端，无法接收到服务端的回复2.只能发送GET请求3.容易被浏览器缓存请求，导致请求发送不出去。CORSCORS是Cross-Origin Resource Sharing的缩写，即跨域资源共享。CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。优点：功能强大缺点：1.需要服务端来配合实现（其实很简单~）2.IE必须IE10以上WebSocket这个貌似就不用多说了，属于没用过也应该听过的一种技术。优点：1.双工通信，浏览器和服务器都可以发起请求2.通信效率高，一次链接可以复用，省去反复的握手环节缺点：1.实现上较为复杂，包括客户端和服务端2.浏览器支持问题localStorage 也存在跨域的问题（通过postMessage解决）CROS方法实现跨域当使用 XMLHttpRequest 发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头 origin，后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin，值就是发起请求的源地址(http://127.0.0.1:8888)，浏览器得到响应会进行判断 Access-Control-Allow-Origin 的值是否和当前的地址相同，只有匹配成功后才进行响应处理。在同源策略的限制下，如何加载静态css和js资源感觉这个问的就是跨域的方法而已, 面试官想要的答案应该是这个Cross-Origin Resource Sharing, 即跨域资源共享。CORS分为两种:简单请求GET, HEAD, POST, 注意，当是POST方法时，Content-Type只有为下列三个字段才算是简单请求。 text/plain multipart/form-data * application/x-www-form-urlencoded简单请求的过程：1.浏览器直接发送CORS请求，具体来说，就是在头部中，添加一个Origin字段。2.如果Origin指定的源，不在许可范围内，会报跨域。3.如果在的话，服务器会返回的响应，会多几个头部字段。Access-Control-Allow-OriginAccess-Control-Allow-Credentials, 表示是否允许发送cookieAccess-Control-Expose-Headers, 可选字段非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。AJAX跨域，有哪些解决方法，访问子域算不算跨域?在某些应用场景下，需要在主域中，调用子域中的某个接口，如果直接在主域中向子域发ajax请求，会报跨域错误，可以用iframe来解决这种跨域问题。在主域的A页面中要用iframe把B页面url地址引过来。123456789101112&lt;iframe id=&quot;iframe&quot; src=&quot;http://baike.baidu.com/B.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; $(function()&#123; try&#123; document.domain = &quot;www.baidu.com&quot;; &#125;catch(e)&#123;&#125; $(&quot;#iframe&quot;).load(function()&#123; var iframe = $(&quot;#iframe&quot;).contentDocument.$; ifram.get(&quot;http://baike.baidu.com/接口&quot;,function(data)&#123;&#125;); &#125;); &#125;);&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Promise学习小结]]></title>
    <url>%2F2018%2F09%2F15%2FPromise%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[用promise手写ajax123456789101112131415161718192021222324// ajax函数将返回Promise对象:function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125;var log = document.getElementById(&apos;test-promise-ajax-result&apos;);var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);p.then(function (text) &#123; // 如果AJAX成功，获得响应内容 log.innerText = text;&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码 log.innerText = &apos;ERROR: &apos; + status;&#125;); 什么是Promise？下面的回答很像在背概念，但是很精辟所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）传统的回调有五大信任问题：调用回调过早调用回调过晚（或没有被调用）调用回调次数过少或过多未能传递所需的环境和参数吞掉可能出现的错误和异常 Promise的解决办法：1.调用回调过早对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用。2.调用回调过晚（或没有被调用）对于一个Promise对象注册的每一个观察回调都是相对独立、互不干预的。而Promise对象调用resolve()和reject()时，每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用。此外，关于回调未调用。正常情况下，没有任何东西可以阻止Promise向你通知它的决议，即使你的JavaScript代码报错了，一会通过异常回调来捕获到。如果Promise永远不被决议的话，Promise本身已提供了竞态的抽象机制来作为解决方案。3.调用回调次数过少或过多Promise的定义方式使得它只能被决议一次。即使代码中出现多次决议，这个Promise也会接受第一次决议，并会忽略掉其他任何后续调用。所以任何通过then()注册的回调只会被调用一次。4.未能传递所需的环境和参数凡是被决议的值都会传递到观察回调中，如果没有显示的决议值也会传递一个undefined给观察回调。需要注意的是，Promise只允许传一个决议值，其他值将会被默默忽略掉。5.吞掉可能出现的错误和异常如果在创建Promise时，存在JavaScript代码错误，会直接导致该Promise的拒绝决议，那么你可以通过reject()来捕获异常，代码中的任何异常都不会吞掉。以上的回答十分的啰嗦，但是如果上面的五点你都能记住的话，你会了解很多关于Promise的细节问题，也会应对一些面试官的追问，如Promise的then()会不会被重复调用 等。Promise中的异步模式有哪些？有什么区别？好吧，这个问题可能会把面试者问懵……可以考虑另一种问法，或者直接进入下一个问题，说一说Promise.all()和Promise.race()的区别。因为ES6中的Promise中只有这两个模式all和race，其他的如first、any、last等都是其他Promise库提供的。回到问题本身，Promise.all()和Promise.race()的区别all会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。race会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？all会立即决议，决议结果是fullfilled，值是undefinedrace会永远都不决议，程序卡死……如何确保一个变量是可信任的Promise（Promise.resolve方法传入不同值的不同处理有哪些）可以通过Promise.resolve()方法对不确定的值进行Promise化，返回一个Promise对象。如果是一个立即值，如一个普通变量，那么该Promise会立即决议为成功。如果是一个Promise值，那么会将该Promise直接返回赋值给这个Promise，不会有额外开销。如果是一个类Promise值， 比如其中含有名称为then的成员变量，那么会将then展开形成一个新的Promise对象。Promise是如何捕获异常的？与传统的try/catch相比有什么优势？传统的try/catch捕获异常方式是无法捕获异步的异常的，代码如下：try { setTimeout(function(){ undefined(); //undefined不是一个方法，会抛出异常 }, 500)} catch(err){ //这里并不能捕获异常 console.log(err);}而对于Promise对象来说，构造Promise实例时的代码如果出错，则会被认为是一个拒绝的决议，并会向观察回调中传递异常信息。所以即使是一个异步的请求，Promise也是可以捕获异常的。此外，Promise还可以通过catch回调来捕获回调中的异常。Promise是一个不错异步操作解决方案，他解决了传统的通过回调和事件来解决异步操作的诸多问题，如“竞争”，回调信任度低的问题。ES6中也提供了标准的Promise供大家使用。如何解决异步回调地狱promise、generator、async/await有三个函数，内部实现都是异步的，怎么让这三个函数变成一个同步的，以节省时间promise.allPromise状态一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步与回调函数]]></title>
    <url>%2F2018%2F09%2F15%2FJavaScript%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。JavaScript实现异步的原理：首先，js是单线程的语言，即同一时间只能做一件事。Js的宿主环境（比如浏览器，node）是多线程的，宿主环境通过某种方式（事件驱动）使得js具备了异步的属性。浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript线程，UI渲染线程，浏览器事件触发线程。1、JavaScript引擎线程是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个js线程在运行js程序。2.UI渲染线程负责渲染浏览器页面，当界面需要重绘repaint或者由于某种操作引发回流reflow时，该线程就会执行。但注意UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起，UI更新会被保存在一个队列中，等到JS引擎空闲时立即被执行。3.事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的列尾，等待js引擎处理。这些事件可能来自js引擎当前执行代码块如setTimeOut、也可能来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于js的单线程关系，所有这些事件都得排队等JS引擎处理。总结：当js触发到异步任务时，会将异步任务交给浏览器进行执行，当有执行结果时，会把异步任务的回调插入待处理队列的队尾。注意：JS的工作机制是当前线程空闲的情况下才会执行异步代码的回调，即当所有同步任务执行完毕后才会执行异步任务的回调。AJAX发送异步请求时浏览器做了什么？1.JS创建了一个AJAX请求2.浏览器另外开启了一个AJAX引擎线程，执行ajax请求3.执行得到响应后将回调函数放入任务队列中4.Js执行任务队列中的回调函数有哪些常见的异步回调函数？点击事件，ajax请求，定时器浏览器处理点击事件的过程浏览器开启事件触发线程，等待用户动作，事件触发线程解析为响应事件，转移到js引擎线程，排队等候js引擎的处理。如何实现js的多线程操作：html5的web worker]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX学习小结]]></title>
    <url>%2F2018%2F09%2F15%2FAJAX%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AJAX在jquery底层如何实现12345678910$.ajax(&#123; &quot;url&quot;:&quot;&quot;, //访问路径 &quot;data&quot;:&quot;&quot;, // 需要传输的数据 &quot;type&quot;:&quot;&quot;, // 请求方式 &quot;dataType&quot;:&quot;&quot;, // 返回值类型 &quot;success&quot;:function(obj)&#123;&#125;, // 响应成功时的回调函数 &quot;error&quot;:function(obj)&#123;&#125; // 响应失败时的回调函数&#125;);$.get(URL,callback);$.post(URL,data,callback); 用原生JS实现一个接口，能够用Ajax上传文件并显示上传进度，上传完成后接收一个来自服务器的json数据12345678910111213141516171819202122var xhr = new XMLHttpRequest(); xhr.open(&apos;POST&apos;, &apos;url&apos;); // 上传完成后的回调函数 xhr.onreadystatechange = function() &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;上传出错&apos;); &#125; &#125;; // 获取上传进度 xhr.upload.onprogress = function(event) &#123; console.log(event.loaded) console.log(event.total) if (event.lengthComputable) &#123; var percent = Math.floor(event.loaded / event.total * 100); document.querySelector(&quot;#progress .progress-item&quot;).style.width = percent + &quot;%&quot;; // 设置进度显示 console.log(percent) &#125; &#125;; xhr.send(fd); 请简述 AJAX 及基本步骤？简述 AJAX：AJAX即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 Ajax应用场景Ajax的特点在于异步交互，动态更新web页面，因此它的适用范围是交互较多，频繁读取数据的web应用。场景1. 用Ajax进行数据验证场景2.按需取数据场景3.自动更新页面 AJAX的优点 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。AJAX的缺点1.ajax不支持浏览器back按钮。2.安全问题 AJAX暴露了与服务器交互的细节。3.对搜索引擎的支持比较弱。4.破坏了程序的异常机制。5.不容易调试。6.跨域请求有一定限制。解决方式：jsonp。readyState属性状态有5个可取值： 0=未初始化 ，1=正在加载 2=已加载，3=交互中，4=完成AJAX请求中，readyStatus的状态有哪些0: 未打开, open()方法未调用。1: 未发送, send()方法未调用。2: 已获取响应头, send()方法已被调用，响应头和响应状态已经返回。3: 正在下载响应体, responseText已经获取了部分数据。4: 请求完成，整个请求过程结束了。AJAX 基本步骤：//初始化ajax对象var xhr = new XMLHttpRequest();//连接地址，准备数据xhr.open(“方式”,”地址”,是否为异步);//接收数据完成触发的事件xhr.onload =function(){}//发送数据xhr.send();AJAX的交互模型ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器担负的工作转移到客户端，便于客户端资源来出来，减轻服务器和带宽的负担。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习]]></title>
    <url>%2F2018%2F09%2F15%2FjQuery%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jQuery的优点jQuery的优点 轻量级：大小在30KB左右 强大的选择器：支持几乎所有的css选择器 出色的DOM操作的封装： 可靠的事件处理机制 完善的ajax 不污染顶级变量：只建立一个名为jQuery的对象，其所有的函数方法都在这个对象之下 出色的浏览器兼容性 链式操作方式 隐式迭代：当用jQuery找到带有”.myClass”类的全部元素，然后隐藏他们时，无需遍历每一个返回的元素。相反，jQuery里的方法都被设计成自动操作对象的集合，而不是单独的对象，这使得大量的循环结构变得不再必要，从而大幅的减少了代码量。 丰富的插件支持、完善的文档、开源 导航栏$(document).ready()网页中所有的dom元素都加载完毕后执行，可能dom相关联的东西并没有加载完，能同时编写多个1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;box&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; $(&quot;.level1&gt;a&quot;).click(function)&#123; $(this).addClass(&quot;current&quot;) .next().show(); .parent.siblings().children(&apos;a&apos;).removeClass(&apos;current&apos;); .next().hide(); return false; &#125;&lt;/script&gt; DOM对象和jQuery对象在jQuery对象中无法使用dom对象的任何方法jQuery对象写法：var $variable= jQuery 对象DOM对象写法：var variable= DOM对象 jQuery对象是一个类似数组的对象有两种方法可以将jQuery对象转换成dom对象，即[index]和get[index]var $cr=$(“#cr”);var cr=$cr[0];var cr=$cr.get(0); dom对象转成jQuery对象只需要用$()把dom对象包装起来var cr=document.getElementById(“cr”);var $cr=$(cr);$()函数就是一个jQuery对象的制造工厂 jQuery库中，几乎所有的插件都被限制在它的命名空间里。通常，全局对象都被很好的存储在jQuery命名空间里。 jQuery选择器jQuery选择器的优势简洁的写法支持CSS1到CSS3选择器完善的处理机制$(‘#tt’).css(“color”,”red”);//这里无需判断$(‘#tt’)是否存在$(‘#tt’)获取的永远是对象，即使网页上没有此元素要用jQuery检查某元素是否在网页上存在，需要获取元素的长度来判断，或者转换成dom对象来判断 ##jQuery选择器 基本选择器 #id.classelement*div,span,p.myClass 层次选择器div span //所有子元素div&gt;span //直接子元素.one+div //class为one的下一个div同辈元素pre~siblings //选取pre之后的所有siblings元素 过滤选择器:firstdiv:last //选取div元素中，最后一个div元素input:not(.myClass) //选取class不是myClass的input元素:even:oddinput:eq(index) //选取索引值等于index的input元素:gt(index) //选取索引值大于index的input元素:animated:focus 内容过滤选择器:contains(text):empty //选取不含子元素或者文本的空元素:has(selector):parent //选取含有子元素或者文本的元素 可见性过滤选择器:hidden:visible[attribute=value] 子元素过滤选择器:nth-child(3n) //索引n从1开始的，选取索引值是3的倍数的元素:first-child:only-child:last-child 表单对象属性过滤选择器:enable:disable:checked:selected 表单选择器:input:radio:checkbox:button:text:password jQuery中的dom操作1.DOM CoregetElementById()2.HTML-DOMdocument.formsdocument.src3.CSS-DOMelement.style.color=”red”; 创建节点var $li=$(“香蕉“);$(“ul”).append($li); 插入节点append();appendTo();prepend();prependTo();after();insertAfter();before();insertBefore(); 删除节点remove()detach()empty() jquery与ajaxajax全称为 asynchronous JavaScript and xml ajax的优势 不需要插件支持：被大多数浏览器支持 优秀的用户体验：在不刷新整个页面的前提下更新数据 提高web程序性能：在传统模式中，数据提交通过form表单来实现，而数据的获取靠全页面刷新来重新获取整夜的内容，ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送。 减轻服务器和带宽的负担：ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器担负的工作转移到客户端，便于客户端资源来出来，减轻服务器和带宽的负担。 ajax的缺点破坏了浏览器前进、后退按钮的正常功能对搜索引擎的支持不足 ajax实现ajax的核心是XMLHttpRequest对象，它是实现的关键–发送异步请求、接受响应及执行回调都是通过它来完成。1234567891011121314151617181920212223242526// 异步检查用户名是否存在function checkUsername(username) &#123; // 获取XMLHttpRequest对象 var xhr = new XMLHttpRequest(); var url = &quot;check_username.do?username=&quot; + username; // 配置onreadystatechange xhr.onreadystatechange = function() &#123; // 当服务器已经响应(4)且响应码是200时 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 根据服务器的响应，显示响应的提示消息 if (xhr.responseText == &quot;1&quot;) &#123; // 表示用户名存在 document.getElementById(&quot;username_hint&quot;).innerHTML= &quot;用户名正确&quot;; &#125; else &#123; // 表示用户名不存在 document.getElementById(&quot;username_hint&quot;).innerHTML= &quot;用户名不存在&quot;; &#125; &#125; &#125;; // 调用函数 xhr.open(&quot;GET&quot;, url, true); xhr.send();&#125; jquery中ajax的实现1234567891011$.ajax(&#123; &quot;url&quot;:&quot;&quot;, //访问路径 &quot;data&quot;:&quot;&quot;, // 需要传输的数据 &quot;type&quot;:&quot;&quot;, // 请求方式 &quot;dataType&quot;:&quot;&quot;, // 返回值类型 &quot;success&quot;:function(obj)&#123;&#125;, // 响应成功时的回调函数 &quot;error&quot;:function(obj)&#123;&#125; // 响应失败时的回调函数&#125;);$.get(URL,callback);$.post(URL,data,callback); get、post方法的区别：（1） get是从服务器上获取数据，post是向服务器传送数据。（2） get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。（3） get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。（4） get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 使用Ajax时的返回值类型有哪些？xml、html、script、JSON、jsonp、textxml：返回XML文档，可用 jQuery 处理。html：返回纯文本HTML信息；script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了 “cache” 参数；json：json方式和html方式在请求和服务器中完全是一样，请求的返回值实际上都是String对象，有两点不同，第一：html方式的时候并没有限制返回的字符串格式，而json方式的时候，必须符合json协议的规范。第二：html方式请求完成之后没有做任何的操作直接回调sucuess，而json多了一步就是加了eval，执行返回的字符串，看看源码data = eval_r(“(“ + data + “)”);返回json对象；(方法的返回值是Javabean时，在响应体中响应成json字符串格式)jsonp：jsonp方式的交互方式和js是一样的，本身xmlHttpRequest对象并不能跨域访问，但是script标签的src可以跨域访问，这里就注意两个概念：第一Ajax是不能跨域操作的，第二jQuery的jsonp是可以跨域操作，jsonp到底是什么东西呢？他是一个非官方的定义，目前的规范，需要服务器和客户端进行配合使用；text：返回纯文本字符串。 jQuery的ajax返回值是什么？jQuery中的ajax大家很常用，以至于绝大部分人把他认为是“理所应当”，而忽略了他的底层逻辑和实现原理。$.ajax()方法返回的是一个延迟对象，即$.Deferred的实例。所以你可以像下面这样使用$.ajax()方法`//利用done()和fail()方法来处理ajax请求$.ajax({ url:”http://mydomain.com/memberInfo/get&quot;, async: false}).done(responseData =&gt; { console.log(responseData)}).fail(()=&gt;{ console.error(‘出错了！’)}) jquery和jquery.fn有什么区别，方法是写在哪里的ajax在jquery底层如何实现fn 是什么东西呢。查看jQuery代码，就不难发现。jQuery.fn = jQuery.prototype = { init: function( selector, context ) {//…. //……};原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript没有明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用语句$(“#btn1″) 会生成一个 jQuery类的实例。jQuery.extend(object);为jQuery类添加添加类方法，可以理解为添加静态方法。如：$.extend({ add:function(a,b){return a+b;}});便为jQuery添加一个为add的“静态方法”，之后便可以在引入jQuery的地方,使用这个方法了，$.add(3,4); //return 7jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax在jQuery中的实现]]></title>
    <url>%2F2018%2F09%2F12%2FAJAX%E5%9C%A8jQuery%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[通过ajax动态的加载或关闭协议，但每次点击都发送请求1234&lt;button id=&quot;trigger&quot;&gt;协议&lt;/button&gt;&lt;div style=&quot;display: none;&quot; id=&quot;card&quot;&gt;&lt;/div&gt;var trigger=$(&apos;#trigger&apos;);var card=$(&apos;#card&apos;); 1234trigger.on(&apos;click&apos;,function()&#123; card.load(&apos;card.html&apos;); card.toggle();&#125;); 用load状态来判断是否加载过，加载过就不重新加载 12345678910111213141516171819202122232425262728293031323334353637var load=false;trigger.on(&apos;click&apos;,function()&#123; if(card.is(&apos;:visible&apos;))&#123; card.slideUp(); &#125;else&#123; if(!load)&#123; card.load(&apos;card.html&apos;); load=true; &#125; card.slideDown(); &#125;&#125;);var form=$(&apos;#search&apos;);var input=$(&apos;input#username&apos;);var result=$(&apos;#result&apos;);var username;form.on(&apos;submit&apos;,function(e)&#123; e.preventDefault(); username=input.val(); $.ajax(&apos;https://api.github.com/users/&apos;+username) .done(function(data)&#123; var html=&apos;&lt;div&gt;用户名：&apos;+data.login+&apos;&lt;/div&gt;&apos; &apos;&lt;div&gt;介绍：&apos;+data.bio||&apos;无&apos;+&apos;&lt;/div&gt;&apos;; result.html(html); &#125;)&#125;)$.ajax(&apos;url&apos;,&#123; method:&apos;post&apos;, data:&#123; username:&apos;dd&apos;, password:&apos;1212&apos; &#125;, success:function(data)&#123;&#125;, error:function(data)&#123;&#125;,&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习]]></title>
    <url>%2F2018%2F09%2F11%2FES6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ES6解释ECMA是标准，JavaScript是实现类似于HTML5是标准，IE10，Chrome等是实现低版本浏览器主要支持ES3.1高级浏览器正在从ES5向ES6过渡 ES6兼容性ES6 IE10+，Chrome，移动端，Node.js 编译，转换： 在线转换：每次都需要加载，影响性能引入browser.js 提前编译：Babel ES6主要内容： 变量 函数 数组 字符串 面向对象 Promise generator 模块化 变量let和constvar缺点： 可以重复声明 无法限制修改 没有块级作用域 {}let const 不能重复声明，块级作用域const 不能修改，声明和赋值必须同时进行1234567891011121314151617181920212223242526&lt;input type=&quot;button&quot; value=&quot;按钮1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮2&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮3&quot;&gt;&lt;script&gt; var aBtn=document.getElementsByTagName(&apos;input&apos;); //打印全是3，要用闭包的方式解决 // for(var i=0;i&lt;aBtn.length;i++)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125; //封一个立即执行函数 // for(var i=0;i&lt;aBtn.length;i++)&#123; // (function(i)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125;)(i); // &#125; //使用let块级作用域 for(let i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick=function()&#123; alert(i); &#125; &#125;&lt;/script&gt; 箭头函数function name(){}()=&gt;{}去掉function，加一个=&gt;12345let arr=[12,45,778,45,4,77];arr.sort(function(a,b)&#123; return a-b;&#125;)arr.sort((a,b)=&gt;&#123;return a-b;&#125;); 如果只有一个参数，()可以省 如果只有一个return，{}可以省let show=a=&gt;a*2;show(5); 函数的参数参数的扩展/数组的展开收集剩余参数,rest parameter必须是最后一个 function show(a,b,...args){} 展开数组 展开后的效果，跟直接把数组的内容写在这儿一样 123let arr1=[1,2,3]; //...arr1等价于1,2,3let arr2=[4,5,6];arr=[...arr1,...arr2]; 默认参数1234function show(a,b=12,c=1)&#123; console.log(a,b,c);&#125;show(12,45,88); 解构赋值 左右两边必须结构一样 右边必须是个东西 声明和赋值不能分开let [a,b,c]=[21,23,’faf’];let {a,b,c}={a:12,b:’nn’,c:45}; 数组map,reduce,filter,foreach map 映射 一个对一个，进去多少出来多少123let arr=[12,66,69,44];let result1=arr.map(items=&gt;items*2);let result2=arr.map(item=&gt;item&gt;=60?&apos;及格&apos;:&apos;不及格&apos;); reduce 汇总 一堆出来一个123let result3=arr.reduce(function(temp,item,index)&#123; return temp+item;&#125;); 在reduce里求平均数1234567let result4=arr.reduce(function(temp,item,index)&#123; if(index!=arr.length-1)&#123; return temp+item; &#125;else&#123; return (temp+item)/arr.length; &#125;&#125;); filter 过滤器 forEach 迭代123456789let result5=arr.filter(item=&gt;item%3==0);let arr2=[ &#123;title:&apos;男士皮鞋&apos;,price:198&#125;, &#123;title:&apos;女士皮鞋&apos;,price:19800&#125;, &#123;title:&apos;男士皮包&apos;,price:198&#125;, &#123;title:&apos;女士皮包&apos;,price:19800&#125;];let result6=arr2.filter(json=&gt;json.price&gt;10000);let result7=arr.forEach((item,index)=&gt;&#123;alert(index+&apos;:&apos;+item)&#125;); 字符串多了两个新方法 startsWith,endsWith(根据后缀名显示图标)返回布尔值1234let str=&apos;http://it.kaikeba.com&apos;;if(str.startsWith(&apos;http://&apos;))&#123; alert(&apos;普通网址&apos;);&#125; 模板字符串 ES6的面向对象123456789101112class User&#123; constructor(name,pass)&#123; this.name=name; this.pass=pass; &#125; showName()&#123; alert(this.name); &#125; showPass()&#123; alert(this.pass); &#125;&#125; 新继承:12345678910111213141516171819202122232425262728293031class VipUser extends User&#123; constructor(name,pass,level)&#123; super(name,pass); this.level=level; &#125; showLevel()&#123; alert(this.level); &#125;&#125;var v1=new VipUser(&apos;blue&apos;,123,4);function User(nane,pass)&#123; this.name=name; this.pass=pass;&#125;User.prototype.showName=function()&#123; alert(this.name);&#125;User.prototype.showPass=function()&#123; alert(this.pass);&#125;function VipUser(name,pass.level)&#123; User.call(this,name,pass); this.level=level;&#125;VipUser.prototype=new User();VipUser.prototype.construstor=VipUser;VipUser.prototype.showLevel=function()&#123; alert(this.level);&#125; 面向对象应用-reactjson-json对象let str=’{“a”:”rr”,”b”:5}’;JSON.stringfy(str);-json简写 名字跟值一样的留一个就行 方法可以不要 :function json的标准写法： -只能用双引号 -所有的名字都必须用引号包起来 Promisegenerator生成器函数在中间暂停，踹一步走一步12345678function *show()&#123; alert(&apos;a&apos;); yield;//放弃 alert(&apos;b&apos;);&#125;let genObj=show();genObj.next();genObj.next(); yield可以传参，也可以返回123456789function *show()&#123; alert(&apos;a&apos;); let c=yield;// alert(&apos;b&apos;); alert(c);&#125;let genObj=show();genObj.next(12);//第一个没法给yield传参genObj.next(5); Promise适合一次读一堆generator适合逻辑性 koa实例123456789const koa=require(&apos;koa&apos;);//引入另一个模块const mysql=require(&apos;koa-mysql&apos;);mysql.createPool(&#123;host:&apos;localhost&apos;,user:&apos;root&apos;,password:&apos;123456&apos;,database:&apos;20070114&apos;&#125;);let server=new koa();server.use(function *()&#123; yield db.query(&apos;EELECT * FROM user_table&apos;); this.body=data;&#125;);server.listen(8080); ES7总结数组 includes 数组中是否包含某个东西 数组 JSON for...in 下标key key for...of 值value 错误 JSON不是一个迭代器，for...of不能用于json 数组 keys/values/entries 配合for...of使用，现浏览器不是很支持 keys=&gt;所有的key拿出来 values=&gt;所有的values拿出来 entries=&gt;所有的key-values对拿出来 求幂:3**8不需要runner12345async function readData()&#123; let data1=await $.ajax(&#123;url:&apos;data/1.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/2.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/3.txt&apos;,dataType:&apos;json&apos;&#125;);&#125; 字符串扩展includes(),startsWith(),endsWith()padStart()头部补全,padEnd()尾部补全proxy用于修改某些操作的默认行为，等同于在语言层面作出修改12345678910var user=new Proxy(&#123;&#125;,&#123; get:function(obj,prop)&#123; switch(prop)&#123; case &apos;full_name&apos;:return obj.fname+&apos; &apos;+obj.lname; &#125;, set:function(obj,prop)&#123; switch() &#125;&#125;&#125;)]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学promise]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%88%9D%E5%AD%A6promise%2F</url>
    <content type="text"><![CDATA[同步：同时只能做一件事异步：操作与操作之间没有关系，可以同时进行多个操作 异步：会让代码变得更复杂同步：代码简单 例如淘宝网各个小版块数据读取,这种回调很繁琐1234567891011121314151617ajax(&apos;/banner&apos;,function(banner_data)&#123; ajax(&apos;/hotitems&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;);&#125;,function()&#123; alert(&apos;读取失败&apos;);&#125;); 同步:（假设有这种同步的ajax）1234let banner_data=ajax_async(&apos;baners&apos;);let hotitems_data=ajax_async(&apos;hotitems&apos;);let banners_data=ajax_async(&apos;baners&apos;);let banners_data=ajax_async(&apos;baners&apos;); promise：消除异步操作（同同步一样的方式，书写异步代码）Promise.all 全部要成功Promise.race 竞速，有一个成功就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //resolve成功了，reject失败了 function createPromise(url)&#123; return new Promise(function(resolve,reject)&#123; $.ajax(&#123; url, dataType:&apos;json&apos;, success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;); &#125;); &#125; // p.then(function(arr)&#123; // let [res1,res2]=arr; // alert(&apos;成功了&apos;); // &#125;,function()&#123; // alert(&apos;失败了&apos;); // &#125;) Promise.all([ createPromise(&apos;arr.txt&apos;), createPromise(&apos;json.txt&apos;) ]).then(function(arr)&#123; let [res1,res2]=arr; alert(&apos;全部都成功了&apos;); &#125;,function()&#123; alert(&apos;至少有一个失败了&apos;); &#125;); //jQuery自带promise,$.ajax(...)返回一个promise对象 Promise.all([ $.ajax(&#123;url:&apos;arr.txt&apos;,dataType:&apos;json&apos;&#125;), $.ajax(&#123;url:&apos;json.txt&apos;,dataType:&apos;json&apos;&#125;), ]).then(function(results)&#123; let [arr,json]=results; alert(&apos;成功了&apos;); console.log(arr,json); &#125;,function()&#123; alert(&apos;失败了&apos;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue初学之创建点赞组件]]></title>
    <url>%2F2018%2F09%2F06%2Fvue%E5%88%9D%E5%AD%A6%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%82%B9%E8%B5%9E%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习如何创建一个vue组件 12345678910111213141516171819202122232425262728293031Vue.component(&apos;likes&apos;,&#123; //创建模板 template: `&lt;button v-bind:class=&quot;&#123;liked:liked&#125;&quot; @click=&quot;toggleLike&quot;&gt; 赞 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;`, //存储赞的数量和是否已点赞的状态 data:function()&#123; return &#123; like_count:13, liked:false &#125; &#125;, methods:&#123; toggleLike:function()&#123; //如果未点赞，赞数加一，然后更改点赞状态 if(this.liked==false)&#123; this.like_count++; this.liked=true; &#125;else&#123; //如果已点赞，赞数减一，然后更改点赞状态 this.like_count--; this.liked=false; &#125; &#125; &#125;&#125;);//必须new一下，绑定元素new Vue(&#123; el:&apos;#app&apos;,&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷方式]]></title>
    <url>%2F2018%2F09%2F06%2Fsublime%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[sublime常用快捷键 Ctrl + / —————-注释 Ctrl + P —————-打开命令行进行模糊匹配，来查找文件 Ctrl + Shift +V ———-粘贴过程中保持缩进 Alt + F3 —————–选中选择的词，用来多行同时填写（或重写） Ctrl + H —————–替换 Ctrl + W —————关闭当前文档 Ctrl + D —————多行游标选择可以搭配 Ctrl + K取消选择部分游标产生游标的另外一种方式，按住Shift + 鼠标右键拖动光标 Ctrl + Shift + D ———复制这行文本]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript加载时间线]]></title>
    <url>%2F2018%2F09%2F05%2FJavaScript%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JavaScript加载时间线 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段 document.readyState = ‘loading’ 。 遇到link外部css，创建线程加载，并继续解析文档。 遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。（禁止使用document.write()） 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 当文档解析完成，document.readyState = ‘interactive’ 。 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（禁止使用document.write()）; document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。 从此，以异步响应方式处理用户输入、网络事件等。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
