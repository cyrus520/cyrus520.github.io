<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F13%2FES6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[title: ES6学习date: 2018-09-11 22:23:45tags: - 学习 categories: EMCAscript 1 ES6解释ECMA是标准，JavaScript是实现类似于HTML5是标准，IE10，Chrome等是实现低版本浏览器主要支持ES3.1高级浏览器正在从ES5向ES6过渡 2 ES6兼容性ES6 IE10+，Chrome，移动端，Node.js 2.1 编译，转换： 在线转换：每次都需要加载，影响性能引入browser.js 提前编译：Babel 2.2 ES6主要内容： 变量 函数 数组 字符串 面向对象 Promise generator 模块化 3 变量let和const3.1 var缺点： 可以重复声明 无法限制修改 没有块级作用域 {}let const 不能重复声明，块级作用域const 不能修改，声明和赋值必须同时进行1234567891011121314151617181920212223242526&lt;input type=&quot;button&quot; value=&quot;按钮1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮2&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮3&quot;&gt;&lt;script&gt; var aBtn=document.getElementsByTagName(&apos;input&apos;); //打印全是3，要用闭包的方式解决 // for(var i=0;i&lt;aBtn.length;i++)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125; //封一个立即执行函数 // for(var i=0;i&lt;aBtn.length;i++)&#123; // (function(i)&#123; // aBtn[i].onclick=function()&#123; // alert(i); // &#125; // &#125;)(i); // &#125; //使用let块级作用域 for(let i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick=function()&#123; alert(i); &#125; &#125;&lt;/script&gt; 4 箭头函数function name(){}()=&gt;{}去掉function，加一个=&gt;12345let arr=[12,45,778,45,4,77];arr.sort(function(a,b)&#123; return a-b;&#125;)arr.sort((a,b)=&gt;&#123;return a-b;&#125;); 如果只有一个参数，()可以省 如果只有一个return，{}可以省let show=a=&gt;a*2;show(5); 5 函数的参数5.1 参数的扩展/数组的展开收集剩余参数,rest parameter必须是最后一个 function show(a,b,...args){} 展开数组 展开后的效果，跟直接把数组的内容写在这儿一样 123let arr1=[1,2,3]; //...arr1等价于1,2,3let arr2=[4,5,6];arr=[...arr1,...arr2]; 5.2 默认参数1234function show(a,b=12,c=1)&#123; console.log(a,b,c);&#125;show(12,45,88); 6 解构赋值 左右两边必须结构一样 右边必须是个东西 声明和赋值不能分开let [a,b,c]=[21,23,’faf’];let {a,b,c}={a:12,b:’nn’,c:45}; 7 数组map,reduce,filter,foreach map 映射 一个对一个，进去多少出来多少123let arr=[12,66,69,44];let result1=arr.map(items=&gt;items*2);let result2=arr.map(item=&gt;item&gt;=60?&apos;及格&apos;:&apos;不及格&apos;); reduce 汇总 一堆出来一个123let result3=arr.reduce(function(temp,item,index)&#123; return temp+item;&#125;); 在reduce里求平均数1234567let result4=arr.reduce(function(temp,item,index)&#123; if(index!=arr.length-1)&#123; return temp+item; &#125;else&#123; return (temp+item)/arr.length; &#125;&#125;); filter 过滤器 forEach 迭代123456789let result5=arr.filter(item=&gt;item%3==0);let arr2=[ &#123;title:&apos;男士皮鞋&apos;,price:198&#125;, &#123;title:&apos;女士皮鞋&apos;,price:19800&#125;, &#123;title:&apos;男士皮包&apos;,price:198&#125;, &#123;title:&apos;女士皮包&apos;,price:19800&#125;];let result6=arr2.filter(json=&gt;json.price&gt;10000);let result7=arr.forEach((item,index)=&gt;&#123;alert(index+&apos;:&apos;+item)&#125;); 8 字符串多了两个新方法 startsWith,endsWith(根据后缀名显示图标)返回布尔值1234let str=&apos;http://it.kaikeba.com&apos;;if(str.startsWith(&apos;http://&apos;))&#123; alert(&apos;普通网址&apos;);&#125; 模板字符串 9 ES6的面向对象123456789101112class User&#123; constructor(name,pass)&#123; this.name=name; this.pass=pass; &#125; showName()&#123; alert(this.name); &#125; showPass()&#123; alert(this.pass); &#125;&#125; 新继承:12345678910111213141516171819202122232425262728293031class VipUser extends User&#123; constructor(name,pass,level)&#123; super(name,pass); this.level=level; &#125; showLevel()&#123; alert(this.level); &#125;&#125;var v1=new VipUser(&apos;blue&apos;,123,4);function User(nane,pass)&#123; this.name=name; this.pass=pass;&#125;User.prototype.showName=function()&#123; alert(this.name);&#125;User.prototype.showPass=function()&#123; alert(this.pass);&#125;function VipUser(name,pass.level)&#123; User.call(this,name,pass); this.level=level;&#125;VipUser.prototype=new User();VipUser.prototype.construstor=VipUser;VipUser.prototype.showLevel=function()&#123; alert(this.level);&#125; 10 面向对象应用-react11 json-json对象let str=’{“a”:”rr”,”b”:5}’;JSON.stringfy(str);-json简写 名字跟值一样的留一个就行 方法可以不要 :function json的标准写法： -只能用双引号 -所有的名字都必须用引号包起来 12 Promise13 generator生成器函数在中间暂停，踹一步走一步12345678function *show()&#123; alert(&apos;a&apos;); yield;//放弃 alert(&apos;b&apos;);&#125;let genObj=show();genObj.next();genObj.next(); yield可以传参，也可以返回123456789function *show()&#123; alert(&apos;a&apos;); let c=yield;// alert(&apos;b&apos;); alert(c);&#125;let genObj=show();genObj.next(12);//第一个没法给yield传参genObj.next(5); Promise适合一次读一堆generator适合逻辑性 14 koa实例123456789const koa=require(&apos;koa&apos;);//引入另一个模块const mysql=require(&apos;koa-mysql&apos;);mysql.createPool(&#123;host:&apos;localhost&apos;,user:&apos;root&apos;,password:&apos;123456&apos;,database:&apos;20070114&apos;&#125;);let server=new koa();server.use(function *()&#123; yield db.query(&apos;EELECT * FROM user_table&apos;); this.body=data;&#125;);server.listen(8080); 15 ES7总结数组 includes 数组中是否包含某个东西 数组 JSON for...in 下标key key for...of 值value 错误 JSON不是一个迭代器，for...of不能用于json 数组 keys/values/entries 配合for...of使用，现浏览器不是很支持 keys=&gt;所有的key拿出来 values=&gt;所有的values拿出来 entries=&gt;所有的key-values对拿出来 求幂:3**8不需要runner12345async function readData()&#123; let data1=await $.ajax(&#123;url:&apos;data/1.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/2.txt&apos;,dataType:&apos;json&apos;&#125;); let data1=await $.ajax(&#123;url:&apos;data/3.txt&apos;,dataType:&apos;json&apos;&#125;);&#125; 字符串扩展includes(),startsWith(),endsWith()padStart()头部补全,padEnd()尾部补全proxy用于修改某些操作的默认行为，等同于在语言层面作出修改12345678910var user=new Proxy(&#123;&#125;,&#123; get:function(obj,prop)&#123; switch(prop)&#123; case &apos;full_name&apos;:return obj.fname+&apos; &apos;+obj.lname; &#125;, set:function(obj,prop)&#123; switch() &#125;&#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax在jQuery中的实现]]></title>
    <url>%2F2018%2F09%2F12%2Fajax%E5%9C%A8jQuery%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234&lt;button id=&quot;trigger&quot;&gt;协议&lt;/button&gt;&lt;div style=&quot;display: none;&quot; id=&quot;card&quot;&gt;&lt;/div&gt;var trigger=$(&apos;#trigger&apos;);var card=$(&apos;#card&apos;); 通过ajax动态的加载或关闭协议，但每次点击都发送请求1234trigger.on(&apos;click&apos;,function()&#123; card.load(&apos;card.html&apos;); card.toggle();&#125;); 用load状态来判断是否加载过，加载过就不重新加载 12345678910111213141516171819202122232425262728293031323334353637var load=false;trigger.on(&apos;click&apos;,function()&#123; if(card.is(&apos;:visible&apos;))&#123; card.slideUp(); &#125;else&#123; if(!load)&#123; card.load(&apos;card.html&apos;); load=true; &#125; card.slideDown(); &#125;&#125;);var form=$(&apos;#search&apos;);var input=$(&apos;input#username&apos;);var result=$(&apos;#result&apos;);var username;form.on(&apos;submit&apos;,function(e)&#123; e.preventDefault(); username=input.val(); $.ajax(&apos;https://api.github.com/users/&apos;+username) .done(function(data)&#123; var html=&apos;&lt;div&gt;用户名：&apos;+data.login+&apos;&lt;/div&gt;&apos; &apos;&lt;div&gt;介绍：&apos;+data.bio||&apos;无&apos;+&apos;&lt;/div&gt;&apos;; result.html(html); &#125;)&#125;)$.ajax(&apos;url&apos;,&#123; method:&apos;post&apos;, data:&#123; username:&apos;dd&apos;, password:&apos;1212&apos; &#125;, success:function(data)&#123;&#125;, error:function(data)&#123;&#125;,&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学promise]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%88%9D%E5%AD%A6promise%2F</url>
    <content type="text"><![CDATA[同步：同时只能做一件事异步：操作与操作之间没有关系，可以同时进行多个操作 异步：会让代码变得更复杂同步：代码简单 例如淘宝网各个小版块数据读取,这种回调很繁琐1234567891011121314151617ajax(&apos;/banner&apos;,function(banner_data)&#123; ajax(&apos;/hotitems&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; ajax(&apos;/siders&apos;,function(banner_data)&#123; &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;); &#125;,function()&#123; alert(&apos;读取失败&apos;); &#125;);&#125;,function()&#123; alert(&apos;读取失败&apos;);&#125;); 同步:（假设有这种同步的ajax）1234let banner_data=ajax_async(&apos;baners&apos;);let hotitems_data=ajax_async(&apos;hotitems&apos;);let banners_data=ajax_async(&apos;baners&apos;);let banners_data=ajax_async(&apos;baners&apos;); promise：消除异步操作（同同步一样的方式，书写异步代码）Promise.all 全部要成功Promise.race 竞速，有一个成功就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //resolve成功了，reject失败了 function createPromise(url)&#123; return new Promise(function(resolve,reject)&#123; $.ajax(&#123; url, dataType:&apos;json&apos;, success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;); &#125;); &#125; // p.then(function(arr)&#123; // let [res1,res2]=arr; // alert(&apos;成功了&apos;); // &#125;,function()&#123; // alert(&apos;失败了&apos;); // &#125;) Promise.all([ createPromise(&apos;arr.txt&apos;), createPromise(&apos;json.txt&apos;) ]).then(function(arr)&#123; let [res1,res2]=arr; alert(&apos;全部都成功了&apos;); &#125;,function()&#123; alert(&apos;至少有一个失败了&apos;); &#125;); //jQuery自带promise,$.ajax(...)返回一个promise对象 Promise.all([ $.ajax(&#123;url:&apos;arr.txt&apos;,dataType:&apos;json&apos;&#125;), $.ajax(&#123;url:&apos;json.txt&apos;,dataType:&apos;json&apos;&#125;), ]).then(function(results)&#123; let [arr,json]=results; alert(&apos;成功了&apos;); console.log(arr,json); &#125;,function()&#123; alert(&apos;失败了&apos;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>EMCAscript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue初学之创建点赞组件]]></title>
    <url>%2F2018%2F09%2F06%2Fvue%E5%88%9D%E5%AD%A6%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%82%B9%E8%B5%9E%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习如何创建一个vue组件12345678910111213141516171819202122232425262728293031Vue.component(&apos;likes&apos;,&#123; //创建模板 template: `&lt;button v-bind:class=&quot;&#123;liked:liked&#125;&quot; @click=&quot;toggleLike&quot;&gt; 赞 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;`, //存储赞的数量和是否已点赞的状态 data:function()&#123; return &#123; like_count:13, liked:false &#125; &#125;, methods:&#123; toggleLike:function()&#123; //如果未点赞，赞数加一，然后更改点赞状态 if(this.liked==false)&#123; this.like_count++; this.liked=true; &#125;else&#123; //如果已点赞，赞数减一，然后更改点赞状态 this.like_count--; this.liked=false; &#125; &#125; &#125;&#125;);//必须new一下，绑定元素new Vue(&#123; el:&apos;#app&apos;,&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷方式]]></title>
    <url>%2F2018%2F09%2F06%2Fsublime%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[sublime常用快捷键 Ctrl + / —————-注释 Ctrl + P —————-打开命令行进行模糊匹配，来查找文件 Ctrl + Shift +V ———-粘贴过程中保持缩进 Alt + F3 —————–选中选择的词，用来多行同时填写（或重写） Ctrl + H —————–替换 Ctrl + W —————关闭当前文档 Ctrl + D —————多行游标选择可以搭配 Ctrl + K取消选择部分游标产生游标的另外一种方式，按住Shift + 鼠标右键拖动光标 Ctrl + Shift + D ———复制这行文本]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript加载时间线]]></title>
    <url>%2F2018%2F09%2F05%2FJavaScript%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JavaScript加载时间线 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段 document.readyState = ‘loading’ 。 遇到link外部css，创建线程加载，并继续解析文档。 遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。（禁止使用document.write()） 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 当文档解析完成，document.readyState = ‘interactive’ 。 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（禁止使用document.write()）; document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。 从此，以异步响应方式处理用户输入、网络事件等。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
